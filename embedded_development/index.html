<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="work and study notes"><meta name=author content=Pikaqiu><link href=https://panda-zcj.github.io/note/embedded_development/ rel=canonical><link href=../database/ rel=prev><link href=../qemu/ rel=next><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.5.3, mkdocs-material-9.5.17"><title>嵌入式开发 - Pikaqiu Docs</title><link rel=stylesheet href=../assets/stylesheets/main.bcfcd587.min.css><link rel=stylesheet href=../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script> <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../assets/javascripts/glightbox.min.js"></script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=teal data-md-color-accent=blue> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#_1 class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=.. title="Pikaqiu Docs" class="md-header__button md-logo" aria-label="Pikaqiu Docs" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="m57.7 193 9.4 16.4c8.3 14.5 21.9 25.2 38 29.8l57.9 16.5c17.2 4.9 29 20.6 29 38.5v39.9c0 11 6.2 21 16 25.9s16 14.9 16 25.9v39c0 15.6 14.9 26.9 29.9 22.6 16.1-4.6 28.6-17.5 32.7-33.8l2.8-11.2c4.2-16.9 15.2-31.4 30.3-40l8.1-4.6c15-8.5 24.2-24.5 24.2-41.7v-8.3c0-12.7-5.1-24.9-14.1-33.9l-3.9-3.9c-9-9-21.2-14.1-33.9-14.1H257c-11.1 0-22.1-2.9-31.8-8.4l-34.5-19.7c-4.3-2.5-7.6-6.5-9.2-11.2-3.2-9.6 1.1-20 10.2-24.5l5.9-3c6.6-3.3 14.3-3.9 21.3-1.5l23.2 7.7c8.2 2.7 17.2-.4 21.9-7.5 4.7-7 4.2-16.3-1.2-22.8l-13.6-16.3c-10-12-9.9-29.5.3-41.3l15.7-18.3c8.8-10.3 10.2-25 3.5-36.7l-2.4-4.2c-3.5-.2-6.9-.3-10.4-.3-92.8 0-171.5 60.9-198.2 145zM464 256c0-36.8-9.6-71.4-26.4-101.5L412 164.8c-15.7 6.3-23.8 23.8-18.5 39.8l16.9 50.7c3.5 10.4 12 18.3 22.6 20.9l29.1 7.3c1.2-9 1.8-18.2 1.8-27.5zM0 256a256 256 0 1 1 512 0 256 256 0 1 1-512 0z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Pikaqiu Docs </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 嵌入式开发 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=default data-md-color-primary=teal data-md-color-accent=blue aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=cyan data-md-color-accent=amber aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"/></svg> </label> </form> <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://gitee.com/pikaqiu_zcj/mkdocs title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </div> <div class=md-source__repository> pikaqiu/mkdocs </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="Pikaqiu Docs" class="md-nav__button md-logo" aria-label="Pikaqiu Docs" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="m57.7 193 9.4 16.4c8.3 14.5 21.9 25.2 38 29.8l57.9 16.5c17.2 4.9 29 20.6 29 38.5v39.9c0 11 6.2 21 16 25.9s16 14.9 16 25.9v39c0 15.6 14.9 26.9 29.9 22.6 16.1-4.6 28.6-17.5 32.7-33.8l2.8-11.2c4.2-16.9 15.2-31.4 30.3-40l8.1-4.6c15-8.5 24.2-24.5 24.2-41.7v-8.3c0-12.7-5.1-24.9-14.1-33.9l-3.9-3.9c-9-9-21.2-14.1-33.9-14.1H257c-11.1 0-22.1-2.9-31.8-8.4l-34.5-19.7c-4.3-2.5-7.6-6.5-9.2-11.2-3.2-9.6 1.1-20 10.2-24.5l5.9-3c6.6-3.3 14.3-3.9 21.3-1.5l23.2 7.7c8.2 2.7 17.2-.4 21.9-7.5 4.7-7 4.2-16.3-1.2-22.8l-13.6-16.3c-10-12-9.9-29.5.3-41.3l15.7-18.3c8.8-10.3 10.2-25 3.5-36.7l-2.4-4.2c-3.5-.2-6.9-.3-10.4-.3-92.8 0-171.5 60.9-198.2 145zM464 256c0-36.8-9.6-71.4-26.4-101.5L412 164.8c-15.7 6.3-23.8 23.8-18.5 39.8l16.9 50.7c3.5 10.4 12 18.3 22.6 20.9l29.1 7.3c1.2-9 1.8-18.2 1.8-27.5zM0 256a256 256 0 1 1 512 0 256 256 0 1 1-512 0z"/></svg> </a> Pikaqiu Docs </label> <div class=md-nav__source> <a href=https://gitee.com/pikaqiu_zcj/mkdocs title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </div> <div class=md-source__repository> pikaqiu/mkdocs </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> <span class=md-ellipsis> MkDocs教程 </span> </a> </li> <li class=md-nav__item> <a href=../algorithm/ class=md-nav__link> <span class=md-ellipsis> 面试算法 </span> </a> </li> <li class=md-nav__item> <a href=../database/ class=md-nav__link> <span class=md-ellipsis> 数据库 </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 嵌入式开发 </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 嵌入式开发 </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#1 class=md-nav__link> <span class=md-ellipsis> 1. 芯片架构 </span> </a> <nav class=md-nav aria-label="1. 芯片架构"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#11-arm class=md-nav__link> <span class=md-ellipsis> 1.1. ARM架构种类 </span> </a> <nav class=md-nav aria-label="1.1. ARM架构种类"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#111-cortex-m3cortex-m4 class=md-nav__link> <span class=md-ellipsis> 1.1.1. Cortex-M3/Cortex-M4处理器架构寄存器 </span> </a> </li> <li class=md-nav__item> <a href=#112-cortex-r5 class=md-nav__link> <span class=md-ellipsis> 1.1.2. Cortex-R5处理器架构寄存器 </span> </a> </li> <li class=md-nav__item> <a href=#113-cortex-a class=md-nav__link> <span class=md-ellipsis> 1.1.3. Cortex-A系列寄存器 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#12 class=md-nav__link> <span class=md-ellipsis> 1.2. 中断&amp;异常 </span> </a> <nav class=md-nav aria-label="1.2. 中断&异常"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#121-cortex-m3cortex-m4 class=md-nav__link> <span class=md-ellipsis> 1.2.1. Cortex-M3/Cortex-M4处理器 </span> </a> </li> <li class=md-nav__item> <a href=#122-cortex-r5 class=md-nav__link> <span class=md-ellipsis> 1.2.2. Cortex-R5处理器 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#13-cache class=md-nav__link> <span class=md-ellipsis> 1.3. Cache </span> </a> </li> <li class=md-nav__item> <a href=#14-mpu class=md-nav__link> <span class=md-ellipsis> 1.4. MPU </span> </a> </li> <li class=md-nav__item> <a href=#141-arm-cortex-m4-mpu class=md-nav__link> <span class=md-ellipsis> 1.4.1. ARM Cortex-M4 MPU </span> </a> </li> <li class=md-nav__item> <a href=#15 class=md-nav__link> <span class=md-ellipsis> 1.5. 协处理器 </span> </a> <nav class=md-nav aria-label="1.5. 协处理器"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#151-fpu class=md-nav__link> <span class=md-ellipsis> 1.5.1. FPU </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> <span class=md-ellipsis> 2. 外设 </span> </a> <nav class=md-nav aria-label="2. 外设"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-adc class=md-nav__link> <span class=md-ellipsis> 2.1. ADC </span> </a> </li> <li class=md-nav__item> <a href=#22-pwm class=md-nav__link> <span class=md-ellipsis> 2.2. PWM </span> </a> </li> <li class=md-nav__item> <a href=#23-iic class=md-nav__link> <span class=md-ellipsis> 2.3. IIC </span> </a> </li> <li class=md-nav__item> <a href=#24-spi class=md-nav__link> <span class=md-ellipsis> 2.4. SPI </span> </a> </li> <li class=md-nav__item> <a href=#25-uart class=md-nav__link> <span class=md-ellipsis> 2.5. UART </span> </a> </li> <li class=md-nav__item> <a href=#26-phy class=md-nav__link> <span class=md-ellipsis> 2.6. PHY </span> </a> </li> <li class=md-nav__item> <a href=#27-can class=md-nav__link> <span class=md-ellipsis> 2.7. CAN </span> </a> </li> <li class=md-nav__item> <a href=#28-dma class=md-nav__link> <span class=md-ellipsis> 2.8. DMA </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3 class=md-nav__link> <span class=md-ellipsis> 3. 固件&amp;驱动开发 </span> </a> <nav class=md-nav aria-label="3. 固件&驱动开发"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31 class=md-nav__link> <span class=md-ellipsis> 3.1. 程序烧录 </span> </a> </li> <li class=md-nav__item> <a href=#32 class=md-nav__link> <span class=md-ellipsis> 3.2. 初始化过程 </span> </a> </li> <li class=md-nav__item> <a href=#33 class=md-nav__link> <span class=md-ellipsis> 3.3. 驱动开发 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4 class=md-nav__link> <span class=md-ellipsis> 4. 操作系统 </span> </a> <nav class=md-nav aria-label="4. 操作系统"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#40 class=md-nav__link> <span class=md-ellipsis> 4.0. 内核对象 </span> </a> </li> <li class=md-nav__item> <a href=#41 class=md-nav__link> <span class=md-ellipsis> 4.1. 任务调度 </span> </a> </li> <li class=md-nav__item> <a href=#42 class=md-nav__link> <span class=md-ellipsis> 4.2. 消息队列、信号量、互斥量、事件组、任务通知和软件定时器之间的关系 </span> </a> <nav class=md-nav aria-label="4.2. 消息队列、信号量、互斥量、事件组、任务通知和软件定时器之间的关系"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#421 class=md-nav__link> <span class=md-ellipsis> 4.2.1. 信号量、消息队列 </span> </a> </li> <li class=md-nav__item> <a href=#422 class=md-nav__link> <span class=md-ellipsis> 4.2.2. 事件组 </span> </a> </li> <li class=md-nav__item> <a href=#423 class=md-nav__link> <span class=md-ellipsis> 4.2.3. 软件定时器 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#43 class=md-nav__link> <span class=md-ellipsis> 4.3. 锁 </span> </a> </li> <li class=md-nav__item> <a href=#44 class=md-nav__link> <span class=md-ellipsis> 4.4. 空闲任务与钩子函数 </span> </a> </li> <li class=md-nav__item> <a href=#45 class=md-nav__link> <span class=md-ellipsis> 4.5. 空闲任务的钩子函数与协程（已抛弃） </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5 class=md-nav__link> <span class=md-ellipsis> 5. 协议 </span> </a> <nav class=md-nav aria-label="5. 协议"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51 class=md-nav__link> <span class=md-ellipsis> 5.1. 以太网协议栈 </span> </a> <nav class=md-nav aria-label="5.1. 以太网协议栈"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#511 class=md-nav__link> <span class=md-ellipsis> 5.1.1. 物理层 </span> </a> </li> <li class=md-nav__item> <a href=#512 class=md-nav__link> <span class=md-ellipsis> 5.1.2. 数据链路层 </span> </a> </li> <li class=md-nav__item> <a href=#513 class=md-nav__link> <span class=md-ellipsis> 5.1.3. 网络层 </span> </a> </li> <li class=md-nav__item> <a href=#514 class=md-nav__link> <span class=md-ellipsis> 5.1.4. 传输层 </span> </a> </li> <li class=md-nav__item> <a href=#515 class=md-nav__link> <span class=md-ellipsis> 5.1.5. 会话层 </span> </a> </li> <li class=md-nav__item> <a href=#516 class=md-nav__link> <span class=md-ellipsis> 5.1.6. 表示层 </span> </a> </li> <li class=md-nav__item> <a href=#517 class=md-nav__link> <span class=md-ellipsis> 5.1.7. 应用层 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6 class=md-nav__link> <span class=md-ellipsis> 6. 标准库 </span> </a> <nav class=md-nav aria-label="6. 标准库"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#61-newlib class=md-nav__link> <span class=md-ellipsis> 6.1. newlib </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#7 class=md-nav__link> <span class=md-ellipsis> 7. 待完成 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../qemu/ class=md-nav__link> <span class=md-ellipsis> 芯片功能仿真 </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6 id=__nav_6_label tabindex=0> <span class=md-ellipsis> 操作系统 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_6_label aria-expanded=false> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> 操作系统 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../os/linux/ class=md-nav__link> <span class=md-ellipsis> Linux </span> </a> </li> <li class=md-nav__item> <a href=../os/rtos/ class=md-nav__link> <span class=md-ellipsis> RTOS </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_7> <label class=md-nav__link for=__nav_7 id=__nav_7_label tabindex=0> <span class=md-ellipsis> 编程语言 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_7_label aria-expanded=false> <label class=md-nav__title for=__nav_7> <span class="md-nav__icon md-icon"></span> 编程语言 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../programming_language/c%2B%2B/ class=md-nav__link> <span class=md-ellipsis> C/C++ </span> </a> </li> <li class=md-nav__item> <a href=../programming_language/python/ class=md-nav__link> <span class=md-ellipsis> python </span> </a> </li> <li class=md-nav__item> <a href=../programming_language/shell/ class=md-nav__link> <span class=md-ellipsis> Shell </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#1 class=md-nav__link> <span class=md-ellipsis> 1. 芯片架构 </span> </a> <nav class=md-nav aria-label="1. 芯片架构"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#11-arm class=md-nav__link> <span class=md-ellipsis> 1.1. ARM架构种类 </span> </a> <nav class=md-nav aria-label="1.1. ARM架构种类"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#111-cortex-m3cortex-m4 class=md-nav__link> <span class=md-ellipsis> 1.1.1. Cortex-M3/Cortex-M4处理器架构寄存器 </span> </a> </li> <li class=md-nav__item> <a href=#112-cortex-r5 class=md-nav__link> <span class=md-ellipsis> 1.1.2. Cortex-R5处理器架构寄存器 </span> </a> </li> <li class=md-nav__item> <a href=#113-cortex-a class=md-nav__link> <span class=md-ellipsis> 1.1.3. Cortex-A系列寄存器 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#12 class=md-nav__link> <span class=md-ellipsis> 1.2. 中断&amp;异常 </span> </a> <nav class=md-nav aria-label="1.2. 中断&异常"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#121-cortex-m3cortex-m4 class=md-nav__link> <span class=md-ellipsis> 1.2.1. Cortex-M3/Cortex-M4处理器 </span> </a> </li> <li class=md-nav__item> <a href=#122-cortex-r5 class=md-nav__link> <span class=md-ellipsis> 1.2.2. Cortex-R5处理器 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#13-cache class=md-nav__link> <span class=md-ellipsis> 1.3. Cache </span> </a> </li> <li class=md-nav__item> <a href=#14-mpu class=md-nav__link> <span class=md-ellipsis> 1.4. MPU </span> </a> </li> <li class=md-nav__item> <a href=#141-arm-cortex-m4-mpu class=md-nav__link> <span class=md-ellipsis> 1.4.1. ARM Cortex-M4 MPU </span> </a> </li> <li class=md-nav__item> <a href=#15 class=md-nav__link> <span class=md-ellipsis> 1.5. 协处理器 </span> </a> <nav class=md-nav aria-label="1.5. 协处理器"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#151-fpu class=md-nav__link> <span class=md-ellipsis> 1.5.1. FPU </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> <span class=md-ellipsis> 2. 外设 </span> </a> <nav class=md-nav aria-label="2. 外设"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-adc class=md-nav__link> <span class=md-ellipsis> 2.1. ADC </span> </a> </li> <li class=md-nav__item> <a href=#22-pwm class=md-nav__link> <span class=md-ellipsis> 2.2. PWM </span> </a> </li> <li class=md-nav__item> <a href=#23-iic class=md-nav__link> <span class=md-ellipsis> 2.3. IIC </span> </a> </li> <li class=md-nav__item> <a href=#24-spi class=md-nav__link> <span class=md-ellipsis> 2.4. SPI </span> </a> </li> <li class=md-nav__item> <a href=#25-uart class=md-nav__link> <span class=md-ellipsis> 2.5. UART </span> </a> </li> <li class=md-nav__item> <a href=#26-phy class=md-nav__link> <span class=md-ellipsis> 2.6. PHY </span> </a> </li> <li class=md-nav__item> <a href=#27-can class=md-nav__link> <span class=md-ellipsis> 2.7. CAN </span> </a> </li> <li class=md-nav__item> <a href=#28-dma class=md-nav__link> <span class=md-ellipsis> 2.8. DMA </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3 class=md-nav__link> <span class=md-ellipsis> 3. 固件&amp;驱动开发 </span> </a> <nav class=md-nav aria-label="3. 固件&驱动开发"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31 class=md-nav__link> <span class=md-ellipsis> 3.1. 程序烧录 </span> </a> </li> <li class=md-nav__item> <a href=#32 class=md-nav__link> <span class=md-ellipsis> 3.2. 初始化过程 </span> </a> </li> <li class=md-nav__item> <a href=#33 class=md-nav__link> <span class=md-ellipsis> 3.3. 驱动开发 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4 class=md-nav__link> <span class=md-ellipsis> 4. 操作系统 </span> </a> <nav class=md-nav aria-label="4. 操作系统"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#40 class=md-nav__link> <span class=md-ellipsis> 4.0. 内核对象 </span> </a> </li> <li class=md-nav__item> <a href=#41 class=md-nav__link> <span class=md-ellipsis> 4.1. 任务调度 </span> </a> </li> <li class=md-nav__item> <a href=#42 class=md-nav__link> <span class=md-ellipsis> 4.2. 消息队列、信号量、互斥量、事件组、任务通知和软件定时器之间的关系 </span> </a> <nav class=md-nav aria-label="4.2. 消息队列、信号量、互斥量、事件组、任务通知和软件定时器之间的关系"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#421 class=md-nav__link> <span class=md-ellipsis> 4.2.1. 信号量、消息队列 </span> </a> </li> <li class=md-nav__item> <a href=#422 class=md-nav__link> <span class=md-ellipsis> 4.2.2. 事件组 </span> </a> </li> <li class=md-nav__item> <a href=#423 class=md-nav__link> <span class=md-ellipsis> 4.2.3. 软件定时器 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#43 class=md-nav__link> <span class=md-ellipsis> 4.3. 锁 </span> </a> </li> <li class=md-nav__item> <a href=#44 class=md-nav__link> <span class=md-ellipsis> 4.4. 空闲任务与钩子函数 </span> </a> </li> <li class=md-nav__item> <a href=#45 class=md-nav__link> <span class=md-ellipsis> 4.5. 空闲任务的钩子函数与协程（已抛弃） </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5 class=md-nav__link> <span class=md-ellipsis> 5. 协议 </span> </a> <nav class=md-nav aria-label="5. 协议"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51 class=md-nav__link> <span class=md-ellipsis> 5.1. 以太网协议栈 </span> </a> <nav class=md-nav aria-label="5.1. 以太网协议栈"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#511 class=md-nav__link> <span class=md-ellipsis> 5.1.1. 物理层 </span> </a> </li> <li class=md-nav__item> <a href=#512 class=md-nav__link> <span class=md-ellipsis> 5.1.2. 数据链路层 </span> </a> </li> <li class=md-nav__item> <a href=#513 class=md-nav__link> <span class=md-ellipsis> 5.1.3. 网络层 </span> </a> </li> <li class=md-nav__item> <a href=#514 class=md-nav__link> <span class=md-ellipsis> 5.1.4. 传输层 </span> </a> </li> <li class=md-nav__item> <a href=#515 class=md-nav__link> <span class=md-ellipsis> 5.1.5. 会话层 </span> </a> </li> <li class=md-nav__item> <a href=#516 class=md-nav__link> <span class=md-ellipsis> 5.1.6. 表示层 </span> </a> </li> <li class=md-nav__item> <a href=#517 class=md-nav__link> <span class=md-ellipsis> 5.1.7. 应用层 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6 class=md-nav__link> <span class=md-ellipsis> 6. 标准库 </span> </a> <nav class=md-nav aria-label="6. 标准库"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#61-newlib class=md-nav__link> <span class=md-ellipsis> 6.1. newlib </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#7 class=md-nav__link> <span class=md-ellipsis> 7. 待完成 </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=_1>嵌入式开发笔记<a class=headerlink href=#_1 title="Permanent link">&para;</a></h1> <h2 id=1>1. 芯片架构<a class=headerlink href=#1 title="Permanent link">&para;</a></h2> <ol> <li> <p><a href=https://community.arm.com/cfs-file/__key/telligent-evolution-components-attachments/01-2057-00-00-00-01-28-19/Cortex_2D00_M-for-Beginners-_2D00_-2017_5F00_CN_5F00_v3.pdf>Cortex-M从零上手必读</a></p> </li> <li> <p><a href=https://broadgeek.com/2021/11/21/d179/ >ARM 架构家族史</a></p> </li> </ol> <h3 id=11-arm>1.1. ARM架构种类<a class=headerlink href=#11-arm title="Permanent link">&para;</a></h3> <p>ARM处理器架构有多个系列，主要是为了满足不同的市场需求和应用场景。这些系列架构通常包括：</p> <ol> <li> <p><strong>ARM Cortex-A 系列</strong>：这是针对高性能应用和多任务处理而设计的系列。它们通常用于智能手机、平板电脑、笔记本电脑、服务器和其他需要高性能计算的设备。Cortex-A系列处理器通常具有高频率、多核心、较大的缓存和先进的功能，如乱序执行等。</p> </li> <li> <p><strong>ARM Cortex-R 系列</strong>：这是专门针对实时应用的系列。Cortex-R系列处理器设计用于对实时任务的快速响应，如汽车控制系统、工业控制和嵌入式系统。它们通常具有低延迟、高吞吐量、可靠性和一致性。</p> </li> <li> <p><strong>ARM Cortex-M 系列</strong>：这是针对低功耗、低成本和嵌入式应用的系列。Cortex-M系列处理器被广泛应用于微控制器（MCU）、传感器、智能家居设备、可穿戴设备等。它们通常具有较低的功耗、较小的体积、简化的指令集和低成本。</p> </li> </ol> <p>这三种系列架构针对不同的应用场景和需求进行了优化，并提供了各自独特的特性和功能。ARM架构的灵活性使得它可以覆盖广泛的市场，并在各种设备中得到应用。</p> <blockquote> <ol> <li><a href=https://community.arm.com/management/archive/cn/ >ARM 中文社区</a></li> <li><a href=pdf/Cortex_M3_ChineseVersion.pdf>Cortex-M3权威指南（中文版）.pdf</a></li> <li><a href=pdf/Cortex_M3_Cortex_M4_chineseversion.pdf>ARM Cortex-M3与Cortex-M4权威指南.pdf</a></li> <li><a href=https://documentation-service.arm.com/static/5f19da2a20b7cf4bc524d99a>arm_cortex_m4_processor_trm.pdf</a></li> <li><a href=https://documentation-service.arm.com/static/5f04288cdbdee951c1cd8969>arm_cortex_r5_processor_trm.pdf</a></li> <li><a href=https://documentation-service.arm.com/static/5e8e1ac688295d1e18d35fde>arm_cortex_a8_processor_trm.pdf</a></li> </ol> </blockquote> <p>下图是三种典型架构示例图</p> <div style="display: flex;"> <div style="margin-right: 10px; width: 30%; height: auto;"> <a class=glightbox href=../image/cortex-m4.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/cortex-m4.png alt="cortex-m4 芯片架构"></a> <p style="text-align: center; color: red;">cortex-m4 芯片架构</p> </div> <div style="margin-right: 10px; width: 30%; height: auto;"> <a class=glightbox href=../image/cortex-r5.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/cortex-r5.jpg alt="cortex-R5 芯片架构"></a> <p style="text-align: center; color: green;">cortex-R5 芯片架构</p> </div> <div style="margin-right: 10px; width: 30%; height: auto;"> <a class=glightbox href=../image/cortex-A8.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/cortex-A8.png alt="cortex-A8 芯片架构"></a> <p style="text-align: center; color: blue;">cortex-A8 芯片架构</p> </div> </div> <h4 id=111-cortex-m3cortex-m4>1.1.1. Cortex-M3/Cortex-M4处理器架构寄存器<a class=headerlink href=#111-cortex-m3cortex-m4 title="Permanent link">&para;</a></h4> <p><a class=glightbox href=../image/sepcial_register.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/sepcial_register.png alt=常见寄存器 style="text-align: center; width: 50%; height: 50%; "></a></p> <blockquote> <ul> <li><a href=https://juejin.cn/post/7133446668716310558>寄存器种类和用途参考链接</a></li> </ul> </blockquote> <hr> <p><strong>通用寄存器（General Purpose Registers）</strong></p> <ol> <li>寄存器R0 ~ R12为通用目的寄存器<ul> <li>R0 ~ R7也被称作低寄存器<ul> <li>R0到R7在指令编码中所占的位数较少</li> <li>指令集位域宽度有限，<strong>大部分16位指令只能访问低寄存器</strong></li> </ul> </li> <li>R8 ~ R12被称为高寄存器<ul> <li>可用于32位指令和少部分16位指令，如<code>MOV</code>指令</li> </ul> </li> <li>异常流程中，<strong>R0-R3，R12，R14【链接寄存器LR】 ，程序状态字寄存器xPSR， R15 等会被硬件自动保存到栈中</strong>， 若用到了R4-R11，则需要用PUSH 指令手动保存</li> </ul> </li> <li>R13为栈指针（SP），<code>特殊寄存器CONTROL决定栈指针类型</code><ul> <li>主栈指针（MSP）为默认的栈指针<ul> <li>用于复位后或处理器处于handler模式</li> </ul> </li> <li>进程栈指针（PSP）<ul> <li>用于线程模式</li> </ul> </li> <li>MSP和PSP都是32位寄存器，<code>但最低两位固定为0</code><ul> <li>因为对于 ARM Cortex-M处理器，PUSH和POP指令总是4字节（32位），栈操作的地址也必须对齐到4字节（32位），故最低两位是0</li> </ul> </li> <li>无嵌入式OS的应用推荐使用MSP，存在嵌入式OS时，用户的任务栈使用PSP，OS内核使用MSP<ul> <li>PSP的初始值是未定义的</li> <li>MSP的初始值可以在<code>复位流程中从存储器的第一个字中取出</code>，具体需查阅相关技术文档</li> </ul> </li> </ul> </li> <li> <p>R14为链接寄存器（LR），用于保存<code>函数或子程序调用的返回地址</code></p> <ul> <li><code>在函数或子程序结束时</code>，程序将LR的数值加载至程序计数器（PC）中返回调用程序处并继续执行。</li> <li> <p>在异常处理期间，LR自动更新为特殊的EXC_RETURN（异常返回）数值，以便决定返回继续执行时，使用MSP还是PSP</p> <ul> <li>入栈完成后，栈指针会更新（PSP或者MSP会因为压栈操作而生长）</li> <li>在执行中断服务程序时，<strong>将由MSP负责对堆栈的访问</strong></li> <li> <p><strong>在中断服务程序中</strong>， LR 会被计算赋值为 EXC_RETURN （异常返回），当PC被赋值0xFFFF_FFF0-0xFFFF_FFFF时，不会发生取指，而是进入异常处理流程</p> <p><div style="display: flex;"> <div style="margin-right: 10px; width: 50%; height: auto;"> <a class=glightbox href=../image/Abnormal_execution_flow.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/Abnormal_execution_flow.png alt=EXC_RETURN></a> <p style="text-align: center; color: red;">异常执行流程</p> </div> <div style="margin-right: 10px; width: 50%; height: auto;"> <a class=glightbox href=../image/abnormal_value.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/abnormal_value.jpg alt=EXC_RETURN></a> <p style="text-align: center; color: green;">异常值对应表</p> </div> </div></p> </li> </ul> </li> <li> <p>在函数调用链中，LR 的值会被不断地推送到堆栈，以保留每个函数调用的返回地址。</p> <ul> <li><code>这通常由函数的前导和收尾代码负责，确保在函数执行期间堆栈上的正确管理</code></li> <li>在 Cortex-M 处理器中，由于 Thumb2 指令集（兼容16位和32位指令）的特性，通常使用 <code>BX LR</code> 来实现函数返回<ul> <li><strong>BX（Branch and Exchange）指令</strong> 不仅是一个跳转指令，它还负责根据目标地址的最低位自动选择ARM或Thumb模式</li> <li>如果目标地址的最低位（LSB）为0，则处理器切换到ARM模式</li> <li>如果目标地址的最低位（LSB）为1，则处理器切换到Thumb模式</li> </ul> </li> </ul> </li> <li>R15为程序计数器（PC）</li> <li>可读写寄存器<ul> <li>读操作返回当前指令地址加4<ul> <li>Cortex-M 只支持thumb/thumb2指令集，故地址加2/4（16位/32位指令）</li> </ul> </li> <li>写操作（例如，使用数据传输/处理指令）产生程序跳转</li> </ul> </li> <li>指令必须对齐到长度（半字或字），<code>PC的最低位（LSB）为0</code><ul> <li>使用部分跳转/读存储器指令更新PC时，需要将PC值的LSB置1表示 Thumb状态，否则就会由于试图使用不支持的ARM指令而触发错误异常</li> <li><strong>高级编程语言（包括C和C++）编译器会自动将跳转目标的LSB置位</strong></li> </ul> </li> </ul> </li> </ol> <hr> <p><strong>特殊功能寄存器（Special Function Registers）</strong></p> <ol> <li> <p>xPSR，状态寄存器</p> <table> <thead> <tr> <th>位域范围</th> <th>名称</th> <th>功能描述</th> </tr> </thead> <tbody> <tr> <td><strong>0-8</strong></td> <td><strong>Exception Number</strong></td> <td>当前异常/中断号（0 表示线程模式，非异常）</td> </tr> <tr> <td><strong>9</strong></td> <td><em>保留</em></td> <td>未使用</td> </tr> <tr> <td><strong>10-15</strong></td> <td><strong>ICI/IT</strong></td> <td>中断继续指令（ICI）或 IT[7] 指令块状态（用于条件执行，仅占用bit10）</td> </tr> <tr> <td><strong>16-19</strong></td> <td><strong>GE[3:0]</strong></td> <td>大于或等于标志（仅某些 SIMD 指令使用）</td> </tr> <tr> <td><strong>20-23</strong></td> <td><em>保留</em></td> <td>未使用</td> </tr> <tr> <td><strong>24</strong></td> <td><strong>T</strong></td> <td>Thumb 状态（必须为 <code>1</code>，否则触发错误）</td> </tr> <tr> <td><strong>25</strong></td> <td><strong>IT[2]</strong></td> <td>IT 指令块状态的高位（与位 26、10 共同控制条件执行）</td> </tr> <tr> <td><strong>26</strong></td> <td><strong>IT[1]</strong></td> <td>IT 指令块状态的中位</td> </tr> <tr> <td><strong>27</strong></td> <td><strong>Q</strong></td> <td>粘滞饱和标志（某些运算溢出时置 <code>1</code>，需手动清除）</td> </tr> <tr> <td><strong>28</strong></td> <td><strong>V</strong></td> <td>溢出标志（有符号运算溢出时置 <code>1</code>）</td> </tr> <tr> <td><strong>29</strong></td> <td><strong>C</strong></td> <td>进位/借位标志（无符号运算进位/借位时置 <code>1</code>）</td> </tr> <tr> <td><strong>30</strong></td> <td><strong>Z</strong></td> <td>零标志（运算结果为 <code>0</code> 时置 <code>1</code>）</td> </tr> <tr> <td><strong>31</strong></td> <td><strong>N</strong></td> <td>负数标志（运算结果为负时置 <code>1</code>）</td> </tr> </tbody> </table> <p><strong>5.1. 条件标志（N, Z, C, V）</strong></p> <ul> <li><strong>N (Negative)</strong>: 运算结果为负时置 <code>1</code>（最高位为 <code>1</code>）。</li> <li><strong>Z (Zero)</strong>: 运算结果为 <code>0</code> 时置 <code>1</code>。</li> <li><strong>C (Carry)</strong>: 无符号运算进位（加法）或借位（减法）时置 <code>1</code>。</li> <li><strong>V (oVerflow)</strong>: 有符号运算溢出时置 <code>1</code>。</li> </ul> <p><strong>5.2. 异常号（Exception Number, 0-8 位）</strong></p> <ul> <li>表示当前激活的异常号，例如：</li> <li><code>2</code> = NMI（不可屏蔽中断）</li> <li><code>3</code> = HardFault</li> <li><code>4</code> = MemManage</li> <li><code>11</code> = SVCall（SVC 指令触发）</li> <li><code>15</code> = SysTick 中断</li> <li><code>0</code> 表示无异常（线程模式）。</li> </ul> <p><strong>5.3. T 位（Thumb 状态）</strong></p> <ul> <li>Cortex-M 仅支持 Thumb 指令集，因此该位必须为 <code>1</code>。若被清零，将触发 <strong>UsageFault</strong>。</li> </ul> <p><strong>5.4. Q 位（粘滞饱和标志）</strong></p> <ul> <li>在某些饱和运算指令（如 <code>SSAT</code>, <code>USAT</code>）中，若发生饱和，Q 位被置 <code>1</code>。需手动清除（通过写 <code>APSR</code>）。</li> </ul> <p><strong>5.5. IT 位（条件执行状态）</strong></p> <ul> <li><strong>IT[7:5]</strong>（由位 26、25、10 组成）控制 <code>IT</code> 指令块的条件执行流程。例如： <div class=highlight><pre><span></span><code><a id=__codelineno-0-1 name=__codelineno-0-1 href=#__codelineno-0-1></a><span class=nf>ITE</span><span class=w> </span><span class=no>EQ</span><span class=w>        </span><span class=c1>; IF-THEN-ELSE 块，条件为 EQ（Z=1）</span>
<a id=__codelineno-0-2 name=__codelineno-0-2 href=#__codelineno-0-2></a><span class=nf>MOVEQ</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=mi>#1</span><span class=w>  </span><span class=c1>; 若 Z=1，执行</span>
<a id=__codelineno-0-3 name=__codelineno-0-3 href=#__codelineno-0-3></a><span class=nf>MOVNE</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=mi>#0</span><span class=w>  </span><span class=c1>; 若 Z=0，执行</span>
</code></pre></div></li> </ul> <p><strong>5.6. GE[3:0]（大于或等于标志）</strong></p> <ul> <li>仅在特定 SIMD 或并行运算指令（如 <code>UADD8</code>）中使用，标记字节/半字运算结果是否满足条件。</li> </ul> <p><strong>5.7. 典型应用场景</strong></p> <ul> <li><strong>异常处理</strong>：</li> <li>通过 <code>IPSR</code> 读取异常号，确定中断来源。</li> <li>在异常处理结束时，通过 <code>xPSR</code> 恢复状态。</li> <li><strong>条件执行</strong>：</li> <li>根据 <code>N, Z, C, V</code> 标志控制程序分支（如 <code>BEQ</code>, <code>BNE</code>）。</li> <li><strong>调试与错误分析</strong>：</li> <li>检查 <code>Q</code> 位或 <code>V</code> 位，诊断运算溢出问题。</li> </ul> </li> </ol> <hr> <ol> <li> <p>PRIMASK</p> <ul> <li>这是个只有单一比特的寄存器。在它被置 1 后，就关掉所有可屏蔽的异常，只剩下<code>NMI</code>和<code>硬 fault</code>异常可以响应。它的缺省值是 0，表示没有关异常</li> </ul> </li> <li> <p>FAULTMASK</p> <ul> <li>这是个只有 1 个位的寄存器。当它置 1 时，只有<code>NMI</code>才能响应，所有其它的异常，甚至是<code>硬 fault</code>，也通通关闭。它的缺省值也是 0，表示没有关异常</li> </ul> </li> <li> <p>BASEPRI</p> <ul> <li>这个寄存器最多有 9 位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。但若被设成 0，则不关闭任何中断，0 也是缺省值</li> </ul> </li> <li> <p>CONTROL</p> <ul> <li> <p>用于控制处理器的特性，如特权级别切换等</p> <ul> <li> <p><strong>通用位（Cortex-M3/M4 共有）</strong></p> <table> <thead> <tr> <th>位</th> <th>名称</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>0</td> <td><strong>nPRIV</strong></td> <td>控制当前特权级别：<br> - <code>0</code> = <strong>特权模式</strong>（可访问所有资源）<br> - <code>1</code> = <strong>非特权模式</strong>（受限访问）<br> Handler 模式永远都是特权级的</td> </tr> <tr> <td>1</td> <td><strong>SPSEL</strong></td> <td>选择当前使用的堆栈指针：<br> - <code>0</code> = <strong>主堆栈指针（MSP）</strong>（默认）<br> - <code>1</code> = <strong>进程堆栈指针（PSP）</strong> <br> 在 handler 模式下，只允许使用MSP，所以此时不得往该位写1</td> </tr> </tbody> </table> </li> <li> <p><strong>Cortex-M4 特有位</strong></p> <table> <thead> <tr> <th>位</th> <th>名称</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>2</td> <td><strong>FPCA</strong></td> <td>浮点上下文激活（Floating-Point Context Active）：<br> - <code>1</code> = 当前上下文中使用了浮点寄存器（需保存浮点状态）<br> - <code>0</code> = 未使用浮点寄存器</td> </tr> </tbody> </table> </li> </ul> </li> </ul> </li> </ol> <hr> <p><strong>控制寄存器（Control Registers）</strong></p> <ol> <li> <p>NVIC (Nested Vectored Interrupt Controller) 控制器</p> <ul> <li>用于管理中断控制器</li> </ul> </li> <li> <p>SysTick 寄存器</p> <ul> <li>用于系统定时器的配置和控制</li> </ul> </li> <li> <p>MPU (Memory Protection Unit) 寄存器</p> <ul> <li>用于内存保护单元的配置</li> </ul> </li> </ol> <h4 id=112-cortex-r5>1.1.2. Cortex-R5处理器架构寄存器<a class=headerlink href=#112-cortex-r5 title="Permanent link">&para;</a></h4> <p><a class=glightbox href=../image/cortex-r5.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/cortex-r5.png alt="cortex-r5 寄存器参考" style="width: 50%; height: auto;"></a></p> <p>ARM Cortex-R5处理器一般共有 37 个<code>32位寄存器</code>，其中包括：</p> <ul> <li> <p>31 个通用寄存器，6 个状态寄存器</p> <ol> <li> <p>R0~R3 主要用于子程序间传递参数</p> </li> <li> <p>R4~R11 主要用于保存局部变量</p> </li> <li> <p>R12 有时作为内部过程调用的临时寄存器</p> </li> <li> <p>R13 通常用做栈指针，即SP</p> </li> <li> <p>R14 寄存器又被称为链接寄存器（LR）</p> <ul> <li>用于保存子程序以及中断的返回地址</li> <li><strong>若没有LR寄存器</strong>，则可以直接将返回地址保存到栈中，最后执行完之后弹出到pc也行，但是寄存器的访问速度可以远高于栈（存储器SRAM），<strong>所以LR的作用还是很明显的</strong></li> </ul> </li> <li> <p>R15 用作程序计数器（pc）</p> <ul> <li>由于 ARM 采用了流水线机制，当正确读取了 PC 的值后，该值为当前指令地址加 8 个字节，即 PC 指向当前指令的下两条指令地址</li> </ul> </li> <li> <p>CPSR和SPSR都是程序状态寄存器，SPSR和CPSR的位域相同，<strong>其中SPSR是用来保存中断前的CPSR中的值，以便在中断返回之后恢复处理器程序状态</strong></p> <ul> <li> <p>SPSR（Saved Program Status Register）是保存上一个模式的状态寄存器，使用SPSR可以返回先前的模式</p> </li> <li> <p><div style="display: flex;"> <div style="flex: 1;"> <a class=glightbox href=../image/xpsr.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/xpsr.png alt="xPSR 位域参考"></a> </div> <div style="flex: 1;"> <table style="width: 100%;"> <tr> <th>位域</th> <th>作用</th> </tr> <tr> <td>N（Negative）</td> <td>当指令执行结果为负数时被设置为1</td> </tr> <tr> <td>Z（Zero）</td> <td>当指令执行结果为零时被设置为1</td> </tr> <tr> <td>C（Carry）</td> <td>用于无符号算术运算中的进位标志</td> </tr> <tr> <td>V（Overflow）</td> <td>用于有符号算术运算中的溢出标志</td> </tr> <tr> <td>Q（Sticky saturation flag）</td> <td>表示饱和标志，用于饱和运算指令</td> </tr> <tr> <td>GE[3:0]（Greater than or Equal）</td> <td>条件码，用于条件执行</td> </tr> <tr> <td>E（Endianness）</td> <td>指示处理器的字节序模式，1表示大端模式，0表示小端模式</td> </tr> <tr> <td>A（Asynchronous abort disable）</td> <td>禁用异步异常</td> </tr> <tr> <td>I（IRQ interrupt disable）</td> <td>禁用IRQ（普通可屏蔽中断）</td> </tr> <tr> <td>F（FIQ interrupt disable）</td> <td>禁用FIQ（快速可屏蔽中断）</td> </tr> <tr> <td>T（Thumb状态标志）</td> <td>指示处理器当前处于Thumb状态或ARM状态</td> </tr> <tr> <td>M[4:0]</td> <td>b10000 User</td> </tr> <tr> <td></td> <td>b10001 FIQ</td> </tr> <tr> <td></td> <td>b10010 IRQ</td> </tr> <tr> <td></td> <td>b10011 Supervisor</td> </tr> <tr> <td></td> <td>b10111 Abort</td> </tr> <tr> <td></td> <td>b11011 Undefined</td> </tr> <tr> <td></td> <td>b11111 System</td> </tr> </table> </div> </div></p> </li> </ul> </li> </ol> </li> <li> <p>共有 7 种不同的处理器模式：</p> <ol> <li> <p>用户模式（User Mode - USR）</p> <ul> <li>用户模式，用户程序运行在User模式下，拥有受限的系统资源访问权限</li> <li>没有权限去操作其它硬件资源，只能执行处理自己的数据</li> <li>不能切换到其它模式下，<strong>要想访问硬件资源或切换到其它模式只能通过软中断或产生异常</strong></li> </ul> </li> <li> <p>快速中断模式（Fast Interrupt Mode - FIQ）</p> <ul> <li>快中断异常处理模式，发生FIQ中断时的处理器模式，相对于中断而言，快中断拥有更高的响应等级和更低的延迟</li> </ul> </li> <li> <p>普通中断模式（Interrupt Request Mode - IRQ）</p> <ul> <li>中断异常处理模式，发生IRQ中断时的处理器模式</li> </ul> </li> <li> <p>管理模式（Superuser Mode - SVC）</p> <ul> <li>管理员模式，操作系统内核通常运行在该模式下，在处理器复位或者应用程序调用svc指令的时候将会进入到该模式，<code>系统调用就是通过svc指令完成的</code></li> </ul> </li> <li> <p>数据访问中止模式（Data Abort - Abort）</p> <ul> <li>当发生Data Abort exception或者Prefetch Abort exception异常的时候进入这个模式</li> <li>数据访问中止通常是由于<code>访问非法内存、访问权限错误、缺页故障</code>或其他与数据访问相关的错误而引起的</li> </ul> </li> <li> <p>未定义指令中止模式（Undefined Instruction Mode - UND）</p> <ul> <li>处理未定义的指令陷阱，当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真</li> </ul> </li> <li> <p>系统模式（SYS Mode -SYS）</p> <ul> <li><code>系统模式和用户模式共享寄存器视图</code>，操作系统在该模式下可以方便的访问用户模式的寄存器</li> <li>目前大多数系统未使用该模式，利用这个特性我们可以在处理器启动时通过设置系统模式的SP寄存器来达到设置用户模式堆栈的目的，要设置用户模式的其他寄存器也可以这样操作</li> </ul> </li> </ol> </li> <li> <p><strong>除用户模式外，其它模式均为特权模式(Privileged Modes)</strong></p> <ul> <li>ARM内部寄存器和一些片内外设在硬件设计上只允许特权模式下访问</li> <li>特权模式可以自由地切换处理器模式，而用户模式不能直接切换到别的模式</li> </ul> </li> <li> <p><code>特权模式中除系统（system）模式之外的其他5种模式又统称为异常模式</code></p> <ul> <li>它们除了可以通过在特权下的程序切换进入外，也可以由特定的异常进入。比如<ul> <li>硬件产生中断信号进入中断异常模式</li> <li>读取没有权限数据进入中止异常模式</li> <li>执行未定义指令时进入未定义指令中止异常模式</li> </ul> </li> <li><code>其中管理模式（SVC）也称为超级用户模式</code><ul> <li>为操作系统提供<code>软中断的特有模式</code>，正是由于有了软中断，用户程序才可以通过系统调用切换到管理模式</li> </ul> </li> </ul> </li> <li> <p>在每一种处理器模式中有一组相应的寄存器。在任意一种处理器模式下，可见的寄存器：</p> <ul> <li>包括 15 个通用寄存器（R0~R14）、两个状态寄存器以及程序计数器（PC）</li> <li>在所有的寄存器中，有些是各模式共用同一个物理寄存器，<strong>有些寄存器是各个模式自己拥有独立的物理寄存器</strong></li> </ul> </li> </ul> <h4 id=113-cortex-a>1.1.3. Cortex-A系列寄存器<a class=headerlink href=#113-cortex-a title="Permanent link">&para;</a></h4> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/362711700>Cortex-A系列寄存器</a></li> </ol> </blockquote> <h3 id=12>1.2. 中断&amp;异常<a class=headerlink href=#12 title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://www.fomal.cc/posts/c570025b.html>ARM体系架构知识点总结</a></li> <li><a href=https://zhuanlan.zhihu.com/p/347764076>中断的挂起和清除</a></li> </ol> </blockquote> <hr> <p>在ARM处理器中（Exception）和中断（Interrupt）有些差别</p> <ul> <li> <p>两者都是指请求处理器打断正常的程序执行流程，进入特定程序循环的一种机制</p> </li> <li> <p><code>异常也被称为同步中断</code>，是当指令执行时由CPU控制单元产生的，之所以称为同步，<code>是因为只有在一条指令终止执行后CPU才会发出中断</code></p> <ul> <li>一般由程序的错误产生的，或是由内核必须处理的异常条件产生的</li> </ul> </li> <li> <p><code>一般意义的中断是指异步中断</code>，由其他硬件设备依照<code>CPU时钟信号随机产生的</code>。</p> <ul> <li>该请求信号来自各种片上外设和外扩的外设，对CPU来说是<code>异步</code></li> </ul> </li> </ul> <h4 id=121-cortex-m3cortex-m4>1.2.1. Cortex-M3/Cortex-M4处理器<a class=headerlink href=#121-cortex-m3cortex-m4 title="Permanent link">&para;</a></h4> <p>支持2种处理器模式(线程模式，handler模式)，以及2个特权等级(特权级，用户级)</p> <ul> <li> <p>handler模式下只能是特权级</p> <table> <thead> <tr> <th></th> <th>特权级</th> <th>用户级</th> </tr> </thead> <tbody> <tr> <td>异常handler的代码</td> <td>handler模式</td> <td><strong>错误的用法</strong></td> </tr> <tr> <td>主应用程序的代码</td> <td>线程模式</td> <td>线程模式</td> </tr> </tbody> </table> </li> <li> <p>异常编号总共256个，1－15 的对应系统异常，大于等于 16 的则全是外部中断</p> </li> <li>除个别异常的优先级，其它异常的优先级都是可编程的<ul> <li>复位，NMI 以及hard fault，有固定的优先级，不可编程</li> <li><a class=glightbox href=../image/abnormal.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=异常类型和级别 src=../image/abnormal.jpg></a></li> <li>配置中断需要先设置优先级分组，然后设置抢占优先级和从优先级，<strong>数值越小优先级越高</strong></li> </ul> </li> </ul> <hr> <blockquote> <ol> <li><a href=https://blog.csdn.net/u012351051/article/details/125125796>深入分析中断处理过程</a></li> <li><a href=https://www.zhihu.com/question/34914515/answer/2367330784>寄存器与中断流程</a></li> <li><a href=https://zhuanlan.zhihu.com/p/639230009>ARM Cortex-M 异常模型（Exception model）</a></li> </ol> </blockquote> <ol> <li> <p><code>当异常发生时，处理器会把PC设置为一个特定的存储器地址。这一地址放在被称为向量表（vector table）的特定地址范围内，向量表的入口是一些跳转指令，跳转到专门处理某个异常或中断的子程序。</code></p> </li> <li> <p>执行流程如下所示</p> <p><div style="display: flex;"> <div style="margin-right: 10px; width: 50%; height: auto;"> <a class=glightbox href=../image/interrupt_process_flow.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/interrupt_process_flow.png alt=中断处理流程></a> <p style="text-align: center; color: red;">中断处理流程</p> </div> <div style="margin-right: 10px; width: 50%; height: auto;"> <a class=glightbox href=../image/interrupt_example.jpeg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/interrupt_example.jpeg alt=中断嵌套流程></a> <p style="text-align: center; color: green;">中断嵌套流程</p> </div> </div></p> <ol> <li> <p>主程序或应用程序正在运行过程中，中断发生。</p> </li> <li> <p>CPU自动保存现场寄存器，包括（<strong>R0~R3， R12， R14(LR)， 返回地址(PC)， xPSR，栈地址由低到高</strong>），将这8个寄存器值存放到堆栈中，具体是任务堆栈，还是主堆栈，取决于发生中断前正在使用的是MSP还是PSP。</p> <ul> <li> <p>假如发生中断前，正在运行OS的某个任务，即此时使用的是PSP，则将现场的这8个寄存器值使用PSP存储到线程的堆栈中。</p> </li> <li> <p>假如发生中断前，正在使用MSP（裸机程序或中断嵌套），则将现场的8个寄存器值使用MSP存放到主堆栈中。</p> </li> </ul> <p><strong>注：这些工作都是CPU自动完成的，硬件实现，不需要程序员实现。这8个寄存器的值就是栈帧。</strong></p> </li> <li> <p>CPU根据发生中断前的状态，比如正在使用MSP或PSP，当前模式是线程模式或handler模式等，计算查表获取EXC_RETURN值。然后将EXC_RETURN值赋值给LR，<code>这里注意，步骤2中保存的是LR的值，这里是将EXC_RETURN的值更新到LR寄存器，不要混淆。</code></p> <p><strong>注：这些工作是CPU自动完成的，硬件实现，不需要程序员实现。步骤2和3都是进入中断前的准备工作，也就是stacking阶段。</strong></p> <p><a class=glightbox href=../image/exc_return_bit_field.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/exc_return_bit_field.png alt=EXC_RETURN位域 style="width: 50%; height: 50%;"></a></p> <ul> <li>若通过EXC_RETURN计算发现使用FPU，还需要将FPU寄存器入栈</li> </ul> <p><a class=glightbox href=../image/fpu.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/fpu.jpg alt=FPU入栈保护 style="width: 50%; height: 50%;"></a></p> </li> <li> <p>进入中断服务程序，此时假如步骤2和3中使用的是PSP，则CPU会自动切换使用MSP，因为一旦进入中断，CPU的工作模式就变成了Handler模式，而Handler模式默认是使用MSP的。</p> </li> <li> <p>将LR寄存器和其他高级寄存器（R4~R11根据需要选择）压栈。 <strong>注：该步骤必须由程序员来实现，我们必须要将LR压栈，因为返回的时候需要LR的值EXC_RETURN。</strong></p> </li> <li> <p>执行中断服务程序。</p> </li> <li> <p>中断服务程序执行完毕后，调用pop {r4， PC}， 由于步骤4中，是将r4和LR压栈，本步骤出栈，则是将LR的值（EXC_RETURN）赋值给了PC。</p> </li> <li> <p>CPU判断PC的值，发现PC的值在EXC_RETURN值范围，该范围本身在CPU的地址架构中定义就是<code>non-excutable</code>，所以CPU就知道了，原来这是中断要退出的信号，同时会更新SP，变成步骤2中使用的SP，比如由MSP切换到PSP。</p> </li> <li> <p>执行步骤2的反操作，即将进入中断前存储的现场R0~R3， R12， R14， 返回地址（PC）、xPSR 恢复现场，此时PC就被赋值为了真正的返回地址。</p> <p><strong>注：该步骤和步骤7中，出现了2次赋值给PC，但是第一次只是通知CPU，让CPU知道要中断执行完毕，需要退出，然后让CPU自动执行步骤8和9。这样设计的目的是与函数调用流程一致，但是又能让CPU能够区分函数返回和中断返回。</strong></p> </li> <li> <p>由于步骤9中已经实现了<code>恢复现场</code>的效果，所以应用程序继续执行。</p> </li> </ol> </li> </ol> <hr> <p><strong>常规函数调用规则</strong></p> <table> <thead> <tr> <th><strong>寄存器类型</strong></th> <th><strong>责任方</strong></th> <th><strong>用途</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Caller-Saved</strong></td> <td>调用者（Caller）</td> <td>易失性寄存器，函数调用后不保证保留</td> </tr> <tr> <td><strong>Callee-Saved</strong></td> <td>被调用者（Callee）</td> <td>非易失性寄存器，函数调用后必须保留</td> </tr> </tbody> </table> <ul> <li><strong>Caller-Saved寄存器</strong>：调用者在调用函数前保存，防止被调函数破坏</li> <li><strong>Callee-Saved寄存器</strong>：被调函数在使用前自行保存并恢复</li> <li><strong>不需要保存控制状态寄存器，比如xPSR寄存器</strong></li> </ul> <hr> <p><strong>异常处理中的<code>通用寄存器</code>处理</strong></p> <table> <thead> <tr> <th><strong>场景</strong></th> <th><strong>寄存器处理策略</strong></th> </tr> </thead> <tbody> <tr> <td><strong>通用异常处理程序</strong></td> <td>保存所有寄存器（caller-saved + callee-saved）</td> </tr> <tr> <td><strong>高性能中断服务例程</strong></td> <td>选择性保存（仅保存实际使用的寄存器）</td> </tr> </tbody> </table> <ul> <li><strong>核心原则</strong>：异常处理程序必须保证被中断代码的上下文完全恢复，因此默认应保存所有寄存器</li> <li><strong>仅在明确优化需求时</strong>：可针对性减少保存的寄存器数量，但需严格验证安全性</li> </ul> <h4 id=122-cortex-r5>1.2.2. Cortex-R5处理器<a class=headerlink href=#122-cortex-r5 title="Permanent link">&para;</a></h4> <p><a class=glightbox href=../image/cortex_r5_exception.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/cortex_r5_exception.jpg alt=Cortex-R5处理器模式 style="width: 50%; height: 50%;"></a></p> <p>ARM处理器中有7种类型的异常，按<code>优先级从高到低</code>的排列如下：</p> <ul> <li>复位异常（Reset）</li> <li>数据异常（Data Abort）</li> <li>快速中断异常（FIQ）</li> <li>外部中断异常（IRQ）</li> <li>预取异常（Prefetch Abort）</li> <li>未定义指令异常（Undefined interrupt）</li> <li>软中断异常（SWI，例如系统调用）</li> </ul> <p><code>Cortex-R5 处理器在中断或异常处理时，并没有硬件自动压栈的机制。与Cortex-M系列不同，Cortex-R5 处理器通常需要在中断服务例程中手动保存和恢复寄存器状态。</code></p> <p>在 Cortex-R5 处理器中，中断或异常处理时，开发者需要注意以下几点：</p> <ol> <li> <p><strong>手动保存现场：</strong> 中断服务例程的开头通常包括手动保存一部分寄存器的值到堆栈中，以保护现场。这通常包括保存通用寄存器、堆栈指针、链接寄存器等。</p> </li> <li> <p><strong>手动恢复现场：</strong> 在中断服务例程执行完成后，需要手动从堆栈中恢复之前保存的寄存器值，确保程序返回到中断发生时的状态。</p> </li> </ol> <p>以下是一个简单的 Cortex-R5 中断服务例程的示例，其中展示了手动保存和恢复寄存器状态的过程：</p> <div class=highlight><pre><span></span><code><a id=__codelineno-1-1 name=__codelineno-1-1 href=#__codelineno-1-1></a>.global my_interrupt_handler
<a id=__codelineno-1-2 name=__codelineno-1-2 href=#__codelineno-1-2></a>
<a id=__codelineno-1-3 name=__codelineno-1-3 href=#__codelineno-1-3></a>.section .text
<a id=__codelineno-1-4 name=__codelineno-1-4 href=#__codelineno-1-4></a>
<a id=__codelineno-1-5 name=__codelineno-1-5 href=#__codelineno-1-5></a>my_interrupt_handler:
<a id=__codelineno-1-6 name=__codelineno-1-6 href=#__codelineno-1-6></a>    stmdb   sp!,{r0-r3,r12,lr}  /* state save from compiled code */
<a id=__codelineno-1-7 name=__codelineno-1-7 href=#__codelineno-1-7></a>    bl  my_interrupt            /* my_interrupt vector */
<a id=__codelineno-1-8 name=__codelineno-1-8 href=#__codelineno-1-8></a>    ldmia   sp!,{r0-r3,r12,lr}  /* state restore from compiled code */
<a id=__codelineno-1-9 name=__codelineno-1-9 href=#__codelineno-1-9></a>    subs    pc, lr, #4          /* adjust return */
</code></pre></div> <ul> <li> <p>Cortex-R系列处理器，LR、SP、xPSR寄存器在异常模式下都有影子寄存器</p> <ul> <li>故异常发生时，硬件会自动将PC保存到LR_exception，xPSR保存到xPSR_exception寄存器</li> <li>因此将LR_exception压栈，相当于异常发生时，将PC的值入栈（即返回地址）</li> <li><strong>在 Cortex-R 中，硬件压栈发生在 SP 切换之后，而 Cortex-M 系列处理器硬件压栈在 SP 切换之前</strong></li> </ul> </li> <li> <p>Cortex-R系列处理器采用多级流水线执行，同时CPU在执行（Execute）阶段时，会经历取指（Fetch）、译码（Decode）两个阶段</p> <ul> <li>一般来说，PC的值会比正在执行的指令的地址多出两个指令长度，因此返回时，需要减去一个指令宽度<ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> <strong>Cortex-R系列的芯片在多级流水线执行过程中，LR_{mode}：返回地址（PC + 偏移，偏移值由异常类型决定）？</strong></li> </ul> </li> <li>RISC-V就不需要调整，mepc（Machine Exception PC）寄存器就直接保存正确的触发异常的指令的下一条指令地址</li> </ul> </li> <li> <p>freertos的任务切换：</p> <div class=highlight><pre><span></span><code><a id=__codelineno-2-1 name=__codelineno-2-1 href=#__codelineno-2-1></a>触发PendSV异常（SWI异常，管理模式（Superuser Mode - SVC））
<a id=__codelineno-2-2 name=__codelineno-2-2 href=#__codelineno-2-2></a>    ↓
<a id=__codelineno-2-3 name=__codelineno-2-3 href=#__codelineno-2-3></a>硬件自动保存 LR_exception 和 SPSR_exception 到 SYS模式栈（通过SRSDB）
<a id=__codelineno-2-4 name=__codelineno-2-4 href=#__codelineno-2-4></a>    ↓
<a id=__codelineno-2-5 name=__codelineno-2-5 href=#__codelineno-2-5></a>切换到SYS模式（CPS #SYS_MODE）
<a id=__codelineno-2-6 name=__codelineno-2-6 href=#__codelineno-2-6></a>    ↓
<a id=__codelineno-2-7 name=__codelineno-2-7 href=#__codelineno-2-7></a>软件保存 R0-R12, R14 到任务栈
<a id=__codelineno-2-8 name=__codelineno-2-8 href=#__codelineno-2-8></a>    ↓
<a id=__codelineno-2-9 name=__codelineno-2-9 href=#__codelineno-2-9></a>保存临界区计数和FPU状态
<a id=__codelineno-2-10 name=__codelineno-2-10 href=#__codelineno-2-10></a>    ↓
<a id=__codelineno-2-11 name=__codelineno-2-11 href=#__codelineno-2-11></a>保存当前SP到TCB
<a id=__codelineno-2-12 name=__codelineno-2-12 href=#__codelineno-2-12></a>    ↓
<a id=__codelineno-2-13 name=__codelineno-2-13 href=#__codelineno-2-13></a>任务切换（加载新任务TCB）
<a id=__codelineno-2-14 name=__codelineno-2-14 href=#__codelineno-2-14></a>    ↓
<a id=__codelineno-2-15 name=__codelineno-2-15 href=#__codelineno-2-15></a>恢复新任务的SP
<a id=__codelineno-2-16 name=__codelineno-2-16 href=#__codelineno-2-16></a>    ↓
<a id=__codelineno-2-17 name=__codelineno-2-17 href=#__codelineno-2-17></a>弹出新任务的寄存器（R0-R12, R14, FPU等）
<a id=__codelineno-2-18 name=__codelineno-2-18 href=#__codelineno-2-18></a>    ↓
<a id=__codelineno-2-19 name=__codelineno-2-19 href=#__codelineno-2-19></a>返回（MOV PC, LR）→ 硬件恢复 LR_exception 和 SPSR_exception
</code></pre></div> </li> </ul> <h3 id=13-cache>1.3. Cache<a class=headerlink href=#13-cache title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/102293437>Cache的基本原理</a></li> </ol> </blockquote> <h3 id=14-mpu>1.4. MPU<a class=headerlink href=#14-mpu title="Permanent link">&para;</a></h3> <p>Memory Protection Unit，内存保护单元。</p> <ol> <li> <p><strong>内存访问权限控制</strong>：MPU 可以配置内存区域的访问权限，包括读、写、执行等权限。通过设置不同的权限，可以限制程序对内存的访问，防止未经授权的读写操作。</p> <ul> <li>保护<code>外设和内存</code>的读写，防止关键数据被意外修改</li> <li>控制内存相关访问属性<ul> <li>指令/数据是否可缓存、代码执行（load/store指令）是否可乱序</li> </ul> </li> </ul> </li> <li> <p><strong>内存分区隔离</strong>：MPU 可以将内存划分为多个独立的区域，每个区域具有不同的访问权限。这种隔离可以防止不同任务或进程之间相互干扰，提高系统的稳定性。</p> <ul> <li>限制任务只能读取具有访问权限的内存区域<ul> <li>在上下文切换操作中完成（一般是PendSV异常处理）MPU的内存属性配置</li> </ul> </li> </ul> </li> <li> <p><strong>异常处理</strong>：MPU 可以检测和响应内存访问异常，如越界访问、非法访问等。当发生异常时，MPU 可以触发相应的异常处理机制，以防止系统崩溃或数据损坏。</p> <ul> <li>检测堆、栈是否溢出</li> </ul> </li> <li> <p><strong>代码保护</strong>：MPU 可以保护程序代码不被非法复制或修改。通过限制对代码段的访问权限，可以防止恶意软件攻击或病毒感染。</p> </li> <li> <p><strong>数据保护</strong>：MPU 可以保护关键数据不受未经授权的读写操作。通过设置数据段的访问权限，可以确保数据的机密性和完整性。</p> </li> </ol> <h3 id=141-arm-cortex-m4-mpu>1.4.1. ARM Cortex-M4 MPU<a class=headerlink href=#141-arm-cortex-m4-mpu title="Permanent link">&para;</a></h3> <p>MPU允许<code>一个进程访问8个内存或外设区域（0~7）</code>，<strong>还有一个编号为-1的背景区域，区域7的优先级最高，区域-1的优先级最低</strong>。</p> <ul> <li>使能MPU但没有设置任何内存区域，此时，背景区域（整个内存空间）生效，特权级程序访问所有地址，而用户级程序会触发MemManage fault。</li> <li>背景区域一般设置为只有特权级访问权限</li> </ul> <p><a class=glightbox href=../image/MPU_protect_area.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/MPU_protect_area.png alt=MPU内存保护区域示意 style="width: 30%; height: 30%;"></a></p> <p>上图显示了一个包含六个区域的示例。区域4与区域0和1重叠，区域5包含于区域3。<code>由于优先级按升序排列，重叠区域(橙色)具有优先级</code>。<strong>因此，如果区域0是可写的，而区域4是不可写的，那么位于0和4之间重叠的地址是不可写的。</strong></p> <ol> <li> <p>MPU对于指令和数据的访问权限并没有做区分，而是使用相同的区域来控制对数据和指令的访问。</p> </li> <li> <p>MPU还能定义其它内存属性，<strong>如一个区域的可缓存性，这些属性都会传递给系统的Cache单元或内存控制器</strong>。</p> </li> </ol> <p><strong>内存类型</strong></p> <p>一般有三种常见的内存类型：</p> <ol> <li> <p>Normal Memory：允许CPU以高效的方式对字节、半字和字进行加载和存储（load/store指令）操作（编译器不知道内存区域类型）。</p> <ul> <li>对于普通内存区域，加载和存储的顺序不一定按照程序中列出的顺序执行。</li> </ul> </li> <li> <p>Device Memory：加载和存储操作严格按照顺序执行，以确保寄存器按照正确的顺序进行设置。</p> </li> <li> <p>Strongly Ordered Memory：一切操作都严格按照程序中列出的顺序执行，CPU会等待加载/存储指令执行完成后才执行程序流中的下一条指令，这会导致性能下降。</p> </li> </ol> <p><strong>内存属性</strong></p> <p>MPU的区域属性和大小寄存器<code>MPU_RASR(Region Attribute and Size Register)用来设置所有内存属性</code>，寄存器各个字段的功能如下表所示：</p> <p><a class=glightbox href=../image/MPU.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/MPU.png alt=MPU内存属性配置 style="width: 50%; height: 50%;"></a></p> <ol> <li> <p>XN：控制代码的执行。当XN=1时，访问对应的内存区域将产生MemManage Fault。</p> </li> <li> <p>AP：控制内存区域的访问权限，如下表所示</p> <p><a class=glightbox href=../image/MPU_AP.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/MPU_AP.png alt="MPU AP内存属性配置" style="width: 50%; height: 50%;"></a></p> </li> <li> <p>S：指示内存区域是否可共享。如果一个区域是可共享的，那么多个总线主控可以同时访问它，并且系统会提供数据同步机制。然而，如果一个区域是不可共享的，则需要软件来控制多个总线访问数据的一致性。</p> <ul> <li><strong>对于有的芯片来说，不支持硬件层的数据同步机制</strong>，S就用来指示该区域是否为non-cacheable</li> </ul> </li> <li> <p>TEX、C、B：这三个字段定义内存区域的缓存属性，并能在一定程度上确定其可共享性（S字段）</p> <p><a class=glightbox href=../image/MPU_TEX.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/MPU_TEX.png alt="MPU TEX内存属性配置" style="width: 50%; height: 50%;"></a></p> <ul> <li>当shareable位为1的时候，缓存的策略不受TEX/C/B字段的影响，而固定为non-cacheable</li> <li> <p><strong>Bufferable和Cacheable的不同？</strong></p> <ul> <li>Bufferable 主要关注内存访问的读写效率，用于预取数据或者根据其缓冲策略决定何时将数据写回内存。而Cacheable 属性则主要关注数据的访问速度，允许处理器将数据存储在高速缓存中以加快访问。</li> <li>Bufferable 属性指示是否允许对该内存区域进行缓冲。如果内存区域被标记为可缓冲，总线可以在内部缓冲数据的传输。然而，需要注意的是，缓冲可能会导致数据的延迟，因为数据实际上并不是立即写入或读取。<ul> <li>Bufferable属性不是直接的总线配置，而是通过内存属性间接控制总线事务的缓冲行为</li> <li><strong>它在硬件层面通过总线协议（如AXI的AxCACHE信号）实现，优化写操作的延迟和总线效率，即通知总线控制器可以延迟完成事务（无需立即写入目标内存），也可以合并写入事务</strong></li> </ul> </li> <li>Cacheable 属性指示是否允许对该内存区域进行缓存。如果内存区域被标记为可缓存，处理器可以将其内容缓存在高速缓存中，以加快对该内存区域的访问速度。这样可以提高程序的执行效率，因为处理器可以更快地访问内存中的数据。然而，缓存可能会导致一致性问题，因为处理器可能不会立即看到对内存的更新。</li> </ul> <table> <thead> <tr> <th>内存类型</th> <th>Bufferable</th> <th>Cacheable</th> <th>典型应用场景</th> </tr> </thead> <tbody> <tr> <td>Strongly-ordered</td> <td>❌</td> <td>❌</td> <td>严格顺序访问的硬件（如中断控制器）</td> </tr> <tr> <td>Device</td> <td>✔️</td> <td>❌</td> <td>外设寄存器（如GPIO、定时器）</td> </tr> <tr> <td>Normal</td> <td>✔️/❌</td> <td>✔️/❌</td> <td>SRAM、Flash（根据性能需求配置）</td> </tr> </tbody> </table> </li> <li> <p>Write through with no write allocate：在命中（缓存中存在所需数据）时，将数据写入缓存和主存。在未命中时，它只更新主存中的块，而不写入缓存。</p> </li> <li>Write-back with no write allocate：当处理器执行写操作时，如果数据已经在缓存中，则只更新缓存中的数据，而不立即写回主存。只有在需要替换缓存中的数据时，才将最新的数据写回主存。</li> <li>Write-back with write and read allocate：当处理器执行写操作时，如果数据已经在缓存中，则更新缓存中的数据并写到主存。当处理器执行读操作时，数据在缓存中不存在，它会将整个块从主存读取到缓存中</li> </ul> </li> <li> <p>SRD：标志特定子区域的启用或禁用状态。如果禁用了某个子区域，那么在该子区域范围内的访问将会被其他启用的区域所重叠覆盖。如果没有其他启用的区域与禁用的子区域重叠，则MPU会产生一个错误，表示该访问是非法的或不允许的。</p> </li> </ol> <p>注意事项：</p> <ol> <li> <p>TCM（Tightly Coupled Memories，紧耦合内存）<strong>始终被视为不可缓存、不共享的普通内存</strong>，而不管MPU为TCM中的内存区域定义了什么样的内存类型属性。</p> </li> <li> <p>在ARM Cortex-M系列处理器中，DMB（数据内存屏障）、DSB（数据同步屏障）、ISB（指令同步屏障）与MPU（内存保护单元）共同协作，确保内存访问的安全性、顺序性和一致性</p> </li> </ol> <table> <thead> <tr> <th><strong>指令/模块</strong></th> <th><strong>作用</strong></th> <th><strong>与MPU的关联</strong></th> </tr> </thead> <tbody> <tr> <td><strong>DMB</strong></td> <td>保证内存访问顺序，不阻塞后续指令</td> <td>在MPU区域属性为Device时，确保写入对外设可见</td> </tr> <tr> <td><strong>DSB</strong></td> <td>强制内存访问完成并暂停流水线</td> <td>MPU配置修改后，确保配置生效前内存操作完成</td> </tr> <tr> <td><strong>ISB</strong></td> <td>清空流水线，重新取指</td> <td>MPU启用/修改后，保证后续指令基于新配置执行</td> </tr> <tr> <td><strong>MPU</strong></td> <td>定义内存区域的权限与属性</td> <td>依赖屏障指令确保配置生效和访问一致性</td> </tr> </tbody> </table> <h3 id=15>1.5. 协处理器<a class=headerlink href=#15 title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/362766531>ARM架构-协处理器</a></li> <li><a href=https://www.digiproto.com/news/176.html>浅谈ARMv7-A协处理器CP15</a></li> </ol> </blockquote> <p>在ARM架构中，协处理器（Co-processor）是一种扩展处理器，用于分担主处理器（CPU）的特定任务，提升系统效率。以下是关于ARM协处理器的详细解析，包括功能分类、寄存器访问方法及架构演变：</p> <hr> <p><strong>一、协处理器的核心作用</strong></p> <ul> <li><strong>功能扩展</strong>：处理主CPU不擅长或效率低下的任务，如浮点运算（VFP）、图像处理（NEON）、调试控制（Debug）、内存管理（MMU/Cache）等。</li> <li><strong>性能优化</strong>：通过硬件加速，减少主处理器的计算负载，提升实时性和能效。</li> <li><strong>灵活性</strong>：允许芯片厂商或第三方通过自定义协处理器（如CP0-CP7）实现专用功能（加密加速、传感器控制等）。</li> </ul> <hr> <p><strong>二、ARM32协处理器的分类与功能</strong></p> <p>ARM32支持 <strong>16个协处理器（cp0~cp15）</strong> ，功能分配如下：</p> <table> <thead> <tr> <th><strong>协处理器</strong></th> <th><strong>功能</strong></th> <th><strong>典型应用</strong></th> </tr> </thead> <tbody> <tr> <td><strong>cp15</strong></td> <td>系统控制：内存管理（MMU）、缓存（Cache）、内存保护（MPU）、协处理器访问控制（CPACR）</td> <td>配置页表、缓存策略、权限管理</td> </tr> <tr> <td><strong>cp14</strong></td> <td>调试系统：断点、观察点、跟踪控制</td> <td>调试器连接、实时跟踪代码执行</td> </tr> <tr> <td><strong>cp10/cp11</strong></td> <td>浮点运算（VFP）、SIMD指令（NEON）</td> <td>3D渲染、音频解码、科学计算</td> </tr> <tr> <td><strong>cp8/cp9/cp12/cp13</strong></td> <td>预留给ARM厂商使用</td> <td>未来扩展或专用硬件加速</td> </tr> <tr> <td><strong>cp0-cp7</strong></td> <td>预留给第三方或芯片厂商自定义</td> <td>加密引擎、AI加速器、外设控制</td> </tr> </tbody> </table> <hr> <p><strong>三、检测协处理器存在的方法</strong></p> <p>通过 <strong>CPACR（Co-Processor Access Control Register）</strong> 寄存器可查询协处理器支持情况：</p> <ul> <li> <p><strong>寄存器位域</strong>： </p> <ul> <li><code>CPACR[31:0]</code> 分为多个字段，每字段控制一个协处理器的访问权限（如<code>CPACR[23:20]</code>控制cp11，<code>CPACR[19:16]</code>控制cp10）。 </li> <li>字段值含义： <ul> <li><code>0b00</code>：禁止访问（协处理器可能不存在或未启用）。 </li> <li><code>0b01</code>：仅特权模式（如内核态）可访问。 </li> <li><code>0b11</code>：全模式可访问（若硬件支持）。 </li> </ul> </li> </ul> </li> <li> <p><strong>操作示例（ARMv7汇编）</strong>： </p> </li> </ul> <div class=highlight><pre><span></span><code><a id=__codelineno-3-1 name=__codelineno-3-1 href=#__codelineno-3-1></a><span class=c1>; 读取CPACR的值到寄存器R0</span>
<a id=__codelineno-3-2 name=__codelineno-3-2 href=#__codelineno-3-2></a><span class=c1>; 语法：MRC &lt;coproc&gt;, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</span>
<a id=__codelineno-3-3 name=__codelineno-3-3 href=#__codelineno-3-3></a><span class=nf>MRC</span><span class=w> </span><span class=no>p15</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=no>c1</span><span class=p>,</span><span class=w> </span><span class=no>c0</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=w>   </span>
<a id=__codelineno-3-4 name=__codelineno-3-4 href=#__codelineno-3-4></a>
<a id=__codelineno-3-5 name=__codelineno-3-5 href=#__codelineno-3-5></a><span class=c1>; 检查cp10/cp11是否启用（例如VFP/NEON支持）</span>
<a id=__codelineno-3-6 name=__codelineno-3-6 href=#__codelineno-3-6></a><span class=nf>TST</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=c1>#(0xF &lt;&lt; 20)         ; 检查cp10（位19:16）和cp11（位23:20）</span>
<a id=__codelineno-3-7 name=__codelineno-3-7 href=#__codelineno-3-7></a><span class=nf>BNE</span><span class=w> </span><span class=no>vfp_neon_supported</span><span class=w>       </span><span class=c1>; 若不为0，表示协处理器存在且可访问</span>
</code></pre></div> <hr> <p><strong>四、ARM64架构的协处理器演变</strong></p> <p>在ARMv8（ARM64）中，协处理器概念被弱化，其功能主要通过以下方式实现：</p> <ol> <li> <p><strong>系统寄存器替代</strong>：</p> <ul> <li>原cp15的内存管理功能（如TTBR0_EL1、SCTLR_EL1）改为直接通过系统寄存器访问。 </li> <li>示例：启用MMU不再通过协处理器指令，而是配置<code>SCTLR_EL1.M</code>位。 </li> </ul> </li> <li> <p><strong>专用指令集扩展</strong>：</p> <ul> <li>浮点/SIMD（NEON）指令直接集成到主指令集（如ARM64的<code>ASIMD</code>），无需协处理器编号。 </li> <li>调试功能通过系统寄存器（如<code>DBGDTRTX_EL0</code>）控制。 </li> </ul> </li> <li> <p><strong>第三方加速接口</strong>：</p> <ul> <li>自定义加速任务更多通过总线协议（如AMBA ACE）或专用加速器（如NPU）实现，而非传统协处理器。</li> </ul> </li> </ol> <hr> <p><strong>五、协处理器的实际应用场景</strong></p> <ol> <li> <p><strong>启用浮点运算（ARMv7）</strong>：<br> <div class=highlight><pre><span></span><code><a id=__codelineno-4-1 name=__codelineno-4-1 href=#__codelineno-4-1></a><span class=c1>// 1. 检查CPACR是否允许访问cp10/cp11</span>
<a id=__codelineno-4-2 name=__codelineno-4-2 href=#__codelineno-4-2></a><span class=kt>uint32_t</span><span class=w> </span><span class=n>cpacr</span><span class=p>;</span>
<a id=__codelineno-4-3 name=__codelineno-4-3 href=#__codelineno-4-3></a><span class=kr>__asm</span><span class=w> </span><span class=k>volatile</span><span class=p>(</span><span class=s>&quot;MRC p15, 0, %0, c1, c0, 2&quot;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=s>&quot;=r&quot;</span><span class=p>(</span><span class=n>cpacr</span><span class=p>));</span>
<a id=__codelineno-4-4 name=__codelineno-4-4 href=#__codelineno-4-4></a><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>cpacr</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>(</span><span class=mh>0xF</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>20</span><span class=p>))</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span><span class=c1>// cp10/cp11已启用</span>
<a id=__codelineno-4-5 name=__codelineno-4-5 href=#__codelineno-4-5></a><span class=w>    </span><span class=c1>// 2. 启用浮点单元（以Cortex-M4为例）</span>
<a id=__codelineno-4-6 name=__codelineno-4-6 href=#__codelineno-4-6></a><span class=w>    </span><span class=n>SCB</span><span class=o>-&gt;</span><span class=n>CPACR</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=p>(</span><span class=mh>0xF</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>20</span><span class=p>);</span><span class=w>     </span><span class=c1>// 允许全权限访问</span>
<a id=__codelineno-4-7 name=__codelineno-4-7 href=#__codelineno-4-7></a><span class=w>    </span><span class=n>__DSB</span><span class=p>();</span><span class=w>                       </span><span class=c1>// 数据同步屏障</span>
<a id=__codelineno-4-8 name=__codelineno-4-8 href=#__codelineno-4-8></a><span class=w>    </span><span class=n>__ISB</span><span class=p>();</span><span class=w>                       </span><span class=c1>// 指令同步屏障</span>
<a id=__codelineno-4-9 name=__codelineno-4-9 href=#__codelineno-4-9></a><span class=p>}</span>
</code></pre></div></p> </li> <li> <p><strong>配置MMU（cp15操作）</strong>：<br> <div class=highlight><pre><span></span><code><a id=__codelineno-5-1 name=__codelineno-5-1 href=#__codelineno-5-1></a><span class=c1>; 设置页表基地址（TTBR0）</span>
<a id=__codelineno-5-2 name=__codelineno-5-2 href=#__codelineno-5-2></a><span class=nf>LDR</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=err>=</span><span class=no>page_table_base</span>
<a id=__codelineno-5-3 name=__codelineno-5-3 href=#__codelineno-5-3></a><span class=nf>MCR</span><span class=w> </span><span class=no>p15</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=no>c2</span><span class=p>,</span><span class=w> </span><span class=no>c0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w>    </span><span class=c1>; 写入TTBR0</span>
<a id=__codelineno-5-4 name=__codelineno-5-4 href=#__codelineno-5-4></a>
<a id=__codelineno-5-5 name=__codelineno-5-5 href=#__codelineno-5-5></a><span class=c1>; 启用MMU</span>
<a id=__codelineno-5-6 name=__codelineno-5-6 href=#__codelineno-5-6></a><span class=nf>MRC</span><span class=w> </span><span class=no>p15</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=no>c1</span><span class=p>,</span><span class=w> </span><span class=no>c0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w>    </span><span class=c1>; 读取SCTLR</span>
<a id=__codelineno-5-7 name=__codelineno-5-7 href=#__codelineno-5-7></a><span class=nf>ORR</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=mi>#1</span><span class=w>               </span><span class=c1>; 设置SCTLR.M位</span>
<a id=__codelineno-5-8 name=__codelineno-5-8 href=#__codelineno-5-8></a><span class=nf>MCR</span><span class=w> </span><span class=no>p15</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=no>R0</span><span class=p>,</span><span class=w> </span><span class=no>c1</span><span class=p>,</span><span class=w> </span><span class=no>c0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w>    </span><span class=c1>; 写回SCTLR</span>
<a id=__codelineno-5-9 name=__codelineno-5-9 href=#__codelineno-5-9></a><span class=nf>DSB</span><span class=w>                          </span><span class=c1>; 数据同步</span>
<a id=__codelineno-5-10 name=__codelineno-5-10 href=#__codelineno-5-10></a><span class=nf>ISB</span><span class=w>                          </span><span class=c1>; 清空流水线</span>
</code></pre></div></p> </li> </ol> <hr> <p><strong>六、注意事项</strong></p> <ol> <li><strong>权限与异常</strong>： <ul> <li>未启用协处理器时访问其指令会触发 <strong>未定义指令异常</strong>（如<code>UsageFault</code>）。 </li> </ul> </li> <li><strong>实时性系统</strong>： <ul> <li>频繁切换协处理器状态可能影响中断响应，需评估实时性要求。 </li> </ul> </li> <li><strong>ARMv7-M差异</strong>： <ul> <li>Cortex-M系列（如M3/M4）的浮点单元可能通过独立寄存器（<code>FPCCR</code>）控制，而非cp10/cp11。 </li> </ul> </li> </ol> <hr> <p><strong>七、总结</strong></p> <p>协处理器在ARM32中承担关键的系统扩展功能，通过CPACR可检测其存在性，而ARM64通过系统寄存器和指令集集成简化了这一设计。合理利用协处理器能显著提升特定任务性能，但需结合架构差异和硬件支持进行适配。</p> <h4 id=151-fpu>1.5.1. FPU<a class=headerlink href=#151-fpu title="Permanent link">&para;</a></h4> <div class=highlight><pre><span></span><code><a id=__codelineno-6-1 name=__codelineno-6-1 href=#__codelineno-6-1></a><span class=c1>// 包含必要的头文件</span>
<a id=__codelineno-6-2 name=__codelineno-6-2 href=#__codelineno-6-2></a><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdio.h&gt;</span>
<a id=__codelineno-6-3 name=__codelineno-6-3 href=#__codelineno-6-3></a><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;math.h&gt;</span>
<a id=__codelineno-6-4 name=__codelineno-6-4 href=#__codelineno-6-4></a>
<a id=__codelineno-6-5 name=__codelineno-6-5 href=#__codelineno-6-5></a><span class=c1>// 定义一个函数，用于执行浮点运算</span>
<a id=__codelineno-6-6 name=__codelineno-6-6 href=#__codelineno-6-6></a><span class=kt>float</span><span class=w> </span><span class=nf>calculate</span><span class=p>(</span><span class=kt>float</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<a id=__codelineno-6-7 name=__codelineno-6-7 href=#__codelineno-6-7></a><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w> </span><span class=c1>// 使用浮点数进行计算</span>
<a id=__codelineno-6-8 name=__codelineno-6-8 href=#__codelineno-6-8></a><span class=p>}</span>
<a id=__codelineno-6-9 name=__codelineno-6-9 href=#__codelineno-6-9></a>
<a id=__codelineno-6-10 name=__codelineno-6-10 href=#__codelineno-6-10></a><span class=kt>int</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<a id=__codelineno-6-11 name=__codelineno-6-11 href=#__codelineno-6-11></a><span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>result</span><span class=p>;</span>
<a id=__codelineno-6-12 name=__codelineno-6-12 href=#__codelineno-6-12></a><span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>input1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.5f</span><span class=p>;</span>
<a id=__codelineno-6-13 name=__codelineno-6-13 href=#__codelineno-6-13></a><span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>input2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>2.0f</span><span class=p>;</span>
<a id=__codelineno-6-14 name=__codelineno-6-14 href=#__codelineno-6-14></a>
<a id=__codelineno-6-15 name=__codelineno-6-15 href=#__codelineno-6-15></a><span class=w>    </span><span class=c1>// 启用FPU（具体操作可能因处理器型号而异）</span>
<a id=__codelineno-6-16 name=__codelineno-6-16 href=#__codelineno-6-16></a><span class=w>    </span><span class=c1>// 这是一个示例代码，实际操作可能因处理器型号不同而有所差异</span>
<a id=__codelineno-6-17 name=__codelineno-6-17 href=#__codelineno-6-17></a>
<a id=__codelineno-6-18 name=__codelineno-6-18 href=#__codelineno-6-18></a><span class=w>    </span><span class=c1>// CMSIS库的方式：</span>
<a id=__codelineno-6-19 name=__codelineno-6-19 href=#__codelineno-6-19></a><span class=w>    </span><span class=c1>// 设置CP10和CP11使能为full access</span>
<a id=__codelineno-6-20 name=__codelineno-6-20 href=#__codelineno-6-20></a><span class=w>    </span><span class=n>SCB</span><span class=o>-&gt;</span><span class=n>CPACR</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=p>((</span><span class=mi>3UL</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>10</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span><span class=o>|</span><span class=p>(</span><span class=mi>3UL</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>11</span><span class=o>*</span><span class=mi>2</span><span class=p>));</span><span class=w>  </span>
<a id=__codelineno-6-21 name=__codelineno-6-21 href=#__codelineno-6-21></a>
<a id=__codelineno-6-22 name=__codelineno-6-22 href=#__codelineno-6-22></a><span class=w>    </span><span class=c1>// 调用执行浮点运算的函数</span>
<a id=__codelineno-6-23 name=__codelineno-6-23 href=#__codelineno-6-23></a><span class=w>    </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>calculate</span><span class=p>(</span><span class=n>input1</span><span class=p>,</span><span class=w> </span><span class=n>input2</span><span class=p>);</span>
<a id=__codelineno-6-24 name=__codelineno-6-24 href=#__codelineno-6-24></a>
<a id=__codelineno-6-25 name=__codelineno-6-25 href=#__codelineno-6-25></a><span class=w>    </span><span class=c1>// 打印结果</span>
<a id=__codelineno-6-26 name=__codelineno-6-26 href=#__codelineno-6-26></a><span class=w>    </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;Result: %f</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span>
<a id=__codelineno-6-27 name=__codelineno-6-27 href=#__codelineno-6-27></a>
<a id=__codelineno-6-28 name=__codelineno-6-28 href=#__codelineno-6-28></a><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<a id=__codelineno-6-29 name=__codelineno-6-29 href=#__codelineno-6-29></a><span class=p>}</span>
</code></pre></div> <p>在该示例中，使用了CMSIS库的方式来启用FPU。通过设置 SCB（System Control Block）寄存器的 CPACR（Coprocessor Access Control Register）位，可以使能FPU的访问权限。</p> <p><strong>需要注意的是，具体的操作可能因所使用的处理器型号而有所差异。建议参考相关的ARM Cortex-M处理器的技术文档或参考手册，以获取准确的启用FPU的方法和详细说明。</strong></p> <h2 id=2>2. 外设<a class=headerlink href=#2 title="Permanent link">&para;</a></h2> <h3 id=21-adc>2.1. ADC<a class=headerlink href=#21-adc title="Permanent link">&para;</a></h3> <h3 id=22-pwm>2.2. PWM<a class=headerlink href=#22-pwm title="Permanent link">&para;</a></h3> <h3 id=23-iic>2.3. IIC<a class=headerlink href=#23-iic title="Permanent link">&para;</a></h3> <p>Inter-Integrated Circuit，是由飞利浦公司开发出来的一种串行总线协议，它是一种多主机的总线，当发生主机竞争时，有总线仲裁机制。</p> <p>IIC总线只有2根信号线，一根是数据线SDA，一根是时钟线SCL。<strong>SDA和SCL均为双向信号线，通过上拉电阻接正电源</strong>。当总线空闲时，两根线都是<code>高电平</code>。连接到总线上的任一器件，<code>输出低电平，都将使总线的信号变低。</code></p> <ul> <li>连接总线的器件输出级必须是集电极或漏极开路，以形成<code>线与</code>功能</li> <li>每个具有IIC接口的设备都有一个唯一的地址，也叫做<code>设备地址</code></li> </ul> <p>IIC总线在进行数据传送时，<code>时钟信号SCL为高电平期间，数据线SDA上的数据必须保持稳定</code>。只有在<code>时钟信号为低电平期间，数据线上的数据才允许变化</code>。</p> <p><a class=glightbox href=../image/IIC_example.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/IIC_example.png alt="IIC 传输示意图" style="width: 80%; height: 80%;"></a></p> <ul> <li> <p><strong>时钟信号SCL为高电平期间，传输数据</strong></p> </li> <li> <p>时钟信号SCL为高电平期间，数据线上的电平变化认为是<code>数据的开始和结束</code></p> <ul> <li>起始信号：当时钟线SCL为高电平时，数据线SDA由高变低。</li> <li> <p>停止信号：当时钟线SCL为高电平时，数据线SDA由低变高。</p> </li> <li> <p><a class=glightbox href=../image/iic_example_1.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/iic_example_1.png alt="IIC 传输示意图" style="width: 80%; height: 80%;"></a></p> </li> <li> <p><strong>在起始信号以后，IIC总线就被认为是处于忙状态，直到停止信号以后的几个时钟周期，IIC总线才被认为重新处于空闲状态。</strong></p> </li> </ul> </li> </ul> <p>启动总线后，</p> <ol> <li>必须发送设备地址，其中高4位是器件的类型识别符（EEPROM的识别符为1010）</li> <li>接着3位是片选信号</li> <li>接着1位是读写控制位，读操作为1，写操作为0。</li> <li>第9位是应答信号位，以确定数据传送是否被对方收到。应答信号由接收方在数据开始后的第9个时钟周期发送，在SCL为高电平期间，接收方将SDA拉为低电平产生应答，用来结束一个字节的传输。<strong>也就是说，一帧完整的数据共有9位。</strong><ul> <li>IIC总线每次传送的数据字节不限，<strong>每一个字节必须是8位</strong>。数据传送时，必须先送最高位(MSB)，每个数据字节后面都有一个确认位，也就是应答(ACK)。共9位。</li> </ul> </li> </ol> <p><a class=glightbox href=../image/iic_full_example.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/iic_full_example.png alt="IIC 传输示意图" style="width: 80%; height: 80%;"></a></p> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/94195531>IIC的相关问题</a></li> <li><a href=https://zhuanlan.zhihu.com/p/218202643>IIC的死锁问题</a></li> </ol> </blockquote> <h3 id=24-spi>2.4. SPI<a class=headerlink href=#24-spi title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/290620901>SPI协议详解</a></li> </ol> </blockquote> <h3 id=25-uart>2.5. UART<a class=headerlink href=#25-uart title="Permanent link">&para;</a></h3> <h3 id=26-phy>2.6. PHY<a class=headerlink href=#26-phy title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/647197643>MDIO(clause 22 与 clause 45)接口简介</a></li> <li><a href=https://zhuanlan.zhihu.com/p/424116083>时序图</a></li> <li>读寄存器三种机制<ul> <li>clause 22直接读寄存器</li> <li>clause 45的MMD分页机制</li> <li>利用芯片制造商自由定义的寄存器间接读写寄存器，如0xD寄存器<ul> <li>PHY是 IEEE802.3 中定义的一个标准模块。PHY 寄存器的地址空间为 5 位，因此寄存器范围是0 到31 ，最多有 32 个寄存器。IEEE802.3 定义了地址为0-15 这16个寄存器的功能，地址16-31的寄存器留给芯片制造商自由定义</li> </ul> </li> </ul> </li> <li><a href=https://www.intel.cn/content/www/cn/zh/docs/programmable/683634/20-4/rmii-and-rgmii-phy-interfaces.html>RMII和RGMII PHY接口</a></li> </ol> </blockquote> <ol> <li> <p>概述</p> <p>如下所示，FPGA或者ARM将以太网数据发送给PHY芯片，PHY会将接收数据转换成模拟的差分信号传输到RJ45座子，最后通过网线与CPU、FPGA等网线连接的设备通信。PHY芯片实现的功能相当于OSI模型中的物理层。</p> <p><a class=glightbox href=https://pic4.zhimg.com/v2-ced61a03ab3b0c76719dbd9c14879a9f_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic4.zhimg.com/v2-ced61a03ab3b0c76719dbd9c14879a9f_r.jpg alt=phy信号传输图 style="width: 80%; height: 80%;"></a></p> <ul> <li> <p>上述介绍适用于三速以太网(10M/100M/1000M)，万兆以太网后续会讲解。以太网PHY芯片可以设置不同的传输速率，10M还是100M，全双工还是半双工。</p> </li> <li> <p>要实现上述功能切换，主控芯片需要通过一个接口去配置这些芯片内部的寄存器。 </p> <ul> <li>配置这些寄存器往往没有速度要求，那么串口就是最好的选择，可以减少走线，便于PCB布局布线。</li> <li>摄像头芯片实现这类功能使用的是类似IIC协议的SCCB串口通信协议，<strong>而以太网PHY芯片是通过MDIO这种串行接口实现内部寄存器的配置</strong>。</li> </ul> </li> <li> <p>不同的以太网PHY往往可以通过不同的接口与主控芯片（FPGA/ARM等）传输数据，以三速以太网为例，可以通过MII，RMII，GMII，RGMII进行数据传输。</p> </li> </ul> <p>通过上文描述，<strong>大致可以知道以太网PHY芯片包含三组数据线</strong></p> <ul> <li>一组用于配置其内部寄存器的串行接口MDIO</li> <li>一组与RJ45连接的物理差分接口</li> <li>一组用于和主控芯片传输数据的并行总线，可能是MII、GMII、RMII、GRMII其中一种，与硬件及寄存器配置有关。</li> </ul> <p>下文先讲解以太网PHY芯片与主控芯片不同传输接口信号时序，然后讲解配置寄存器的MDIO接口时序，后文通过对具体主控芯片的手册，原理图讲解来对照这些接口。</p> </li> <li> <p>MII接口</p> <p>该接口相关信号如图所示，有MII（Media Independent Interface）接口大致可以分为两组信号，一组信号负责发送数据给MAC侧，另一组将MAC需要发送的信号输入，然后转换成模拟差分信号，经过RJ45接口输出。</p> <p><a class=glightbox href=https://pic1.zhimg.com/v2-bc889e5ee028acb41f5b89806c7abd38_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic1.zhimg.com/v2-bc889e5ee028acb41f5b89806c7abd38_r.jpg alt=MII接口信号 style="width: 80%; height: 80%;"></a></p> <p>该接口的信号的相关含义如表1所示，表中信号方向针对PHY芯片来说，I表示输入，O表示输出。</p> <p><strong>MII接口信号</strong></p> <table> <thead> <tr> <th style="text-align: center;">信号</th> <th style="text-align: center;">方向</th> <th style="text-align: center;">位宽</th> <th style="text-align: left;">含义</th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">RX_CLK</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">发送时钟，PHY芯片产生，100Mbps时为25MHz，10Mbps时为 2.5MHz。</td> </tr> <tr> <td style="text-align: center;">RX_DV</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示发送的数据有效。</td> </tr> <tr> <td style="text-align: center;">RX_ER</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示发送数据的错误，接收端不接受该数据。</td> </tr> <tr> <td style="text-align: center;">RX_D</td> <td style="text-align: center;">O</td> <td style="text-align: center;">4</td> <td style="text-align: left;">发送数据总线。</td> </tr> <tr> <td style="text-align: center;">TX_CLK</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">接收时钟，PHY芯片产生，频率与RX_CLK一致。</td> </tr> <tr> <td style="text-align: center;">TX_EN</td> <td style="text-align: center;">I</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示接收的数据有效。</td> </tr> <tr> <td style="text-align: center;">TX_ER</td> <td style="text-align: center;">I</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示接收的数据包有误，丢弃该数据包。</td> </tr> <tr> <td style="text-align: center;">TX_D</td> <td style="text-align: center;">I</td> <td style="text-align: center;">4</td> <td style="text-align: left;">接收数据总线。</td> </tr> <tr> <td style="text-align: center;">CRS</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">载波侦测信号，不需要同步于参考时钟，有数据传输，CRS就有效，仅PHY在半双工模式下有效。</td> </tr> <tr> <td style="text-align: center;">COL</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">冲突检测信号，不需要同步于参考时钟，仅PHY在半双工模式下有效。</td> </tr> </tbody> </table> <p>PHY芯片向MAC传输数据的接口时序如下图所示，<strong>PHY芯片在RX_CLK下降沿输出数据RX_DATA，两个时钟发送一字节数据，先发送低四位数据，后发送高四位数据，发送数据时RX_DV信号拉高</strong>。<code>MAC侧在时钟上升沿采集RX_DV和RX_DATA状态</code>。</p> <p><a class=glightbox href=https://pic4.zhimg.com/v2-dd8f07352d05f338311f4223debde22f_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=MAC侧接收数据时序 src=https://pic4.zhimg.com/v2-dd8f07352d05f338311f4223debde22f_r.jpg></a></p> <p>下图是该接口MAC侧发数据给PHY芯片的时序，依旧是下降沿输出数据，方便接收端在上升沿对数据进行采样。</p> <p><a class=glightbox href=https://pic1.zhimg.com/v2-7f9e56f4cf590f7b3bc504101e615738_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=MAC侧发送数据时序 src=https://pic1.zhimg.com/v2-7f9e56f4cf590f7b3bc504101e615738_r.jpg></a></p> <p><strong>MII接口只能实现100Mbps、10Mbps速率的数据传输</strong>，<code>不能实现1000Mbps</code>。 发送、接收的数据线均为4位，则每个时钟周期发送或接收4位数据。</p> <ul> <li>如果要实现100Mbps通信速率，<strong>那么时钟频率就应该是25MHz</strong>。</li> <li>如果要实现10Mbps通信速率，<strong>那么时钟频率就应该是2.5MHz</strong>。</li> </ul> <p>接口的时序总体比较简单，<strong>注意发送、接收的时钟信号都是PHY芯片输出即可</strong>，FPGA一般使用的都是千兆以太网，要求较高时，使用万兆网，所以MII接口在FPGA中不是很常见，在ARM中更常见。</p> </li> <li> <p>RMII接口</p> <p>RMII（Reduced Media Independent Interface）接口其实就是MII接口的简化版本，将TX_CLK和RX_CLK合并为双向时钟线REF_CLK，<strong>由外部的晶振同时给PHY芯片和MAC主控芯片提供时钟信号</strong>。将4位的数据线简化为2位。对应的接口信号如图所示。</p> <p><a class=glightbox href=https://pic2.zhimg.com/v2-a32b11ba41ab2425350520452efbd97d_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=RMII接口信号 src=https://pic2.zhimg.com/v2-a32b11ba41ab2425350520452efbd97d_r.jpg></a></p> <p>RMII接口信号</p> <table> <thead> <tr> <th style="text-align: center;">信号</th> <th style="text-align: center;">方向</th> <th style="text-align: center;">位宽</th> <th style="text-align: left;">含义</th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">REF_CLK</td> <td style="text-align: center;">I</td> <td style="text-align: center;">1</td> <td style="text-align: left;">参考时钟，外部晶振产生，100Mbps时为50MHz，10Mbps时为5MHz。</td> </tr> <tr> <td style="text-align: center;">CRS_DV</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示发送的数据有效。</td> </tr> <tr> <td style="text-align: center;">RX_ER</td> <td style="text-align: center;">O</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示发送数据的错误，接收端不接受该数据。</td> </tr> <tr> <td style="text-align: center;">RX_D</td> <td style="text-align: center;">O</td> <td style="text-align: center;">2</td> <td style="text-align: left;">发送数据总线。</td> </tr> <tr> <td style="text-align: center;">TX_EN</td> <td style="text-align: center;">I</td> <td style="text-align: center;">1</td> <td style="text-align: left;">高电平表示接收的数据有效。</td> </tr> <tr> <td style="text-align: center;">TX_D</td> <td style="text-align: center;">I</td> <td style="text-align: center;">2</td> <td style="text-align: left;">接收数据总线。</td> </tr> </tbody> </table> <p>RMII将发送时钟、接收时钟合并为参考时钟信号，把4位的数据线简化为2位数据线，可以简化PCB布局布线。</p> <p>RMII同样只能实现100Mbps和10Mbps</p> <ul> <li>当以100Mbps速率传输数据时，每个时钟传输2位数据，此时参考时钟应该设置为50MHz。</li> <li>当以10Mbps速率传输数据时，参考时钟应设置为5MHz。</li> </ul> <p><strong>RMII接口时序与MII完全一致，所以不在赘述</strong>。</p> </li> <li> <p>GMII接口</p> <p>GMII（Gigabit Media Independent Interface）接口是比较常见的千兆网接口，对应的接口信号如图所示。</p> <p><a class=glightbox href=https://pic1.zhimg.com/v2-6f3bdaa11fb15664b4d023fcf0684518_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=GMII接口信号 src=https://pic1.zhimg.com/v2-6f3bdaa11fb15664b4d023fcf0684518_r.jpg></a></p> <p>接口信号的含义与MII接口一致，此处就不在赘述，<strong>注意MII的接收时钟和发送时钟均由PHY芯片输出，而GMII的TX_CLK是由MAC输出给PHY芯片的</strong>。此外就是数据位宽由MII的4位变为了8位。</p> <p>PHY芯片发送数据给MAC的接口时序如下图所示，与MII接口一样，PHY芯片在RX_CLK下降沿输出数据，MAC在上升沿采集数据，但是GMII接口每个时钟周期传输一字节数据。</p> <p><a class=glightbox href=https://pic2.zhimg.com/v2-0efea25efa1f0117059a411464fef5c1_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=MAC接收数时序 src=https://pic2.zhimg.com/v2-0efea25efa1f0117059a411464fef5c1_r.jpg></a></p> <p>MAC发送数据到PHY芯片的接口时序如下图所示，在下降沿输出一字节数据即可。</p> <p><a class=glightbox href=https://pic4.zhimg.com/v2-2e1659a9cb2e0fb1db09c806d75a5847_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=MAC发送数据时序 src=https://pic4.zhimg.com/v2-2e1659a9cb2e0fb1db09c806d75a5847_r.jpg></a></p> <p>该接口支持1000Mbps，向下兼容100Mbps和10Mbps。由于数据线位宽为8位，在每个时钟的单沿进行数据传输。<strong>如果要实现1000Mbps传输速率，那么发送和接收的时钟频率应该为125MHz。</strong></p> </li> <li> <p>RGMII接口</p> <p>RGMII（Reduced Gigabit Media Independent Interface）接口就是把GMII接口的数据线做简化处理，也能够实现千兆网，接口信号如图所示。</p> <p><a class=glightbox href=https://pic1.zhimg.com/v2-fb563b102f5c8a201c2534fe79098324_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=RGMII接口信号 src=https://pic1.zhimg.com/v2-fb563b102f5c8a201c2534fe79098324_r.jpg></a></p> <p>相比GMII接口，RGMII接口的数据线由8位缩减到4位，<strong>RX_DV与RX_ER信号合成为RX_CTL信号</strong>。该接口实现1000Mbps传输速率时，时钟依旧是125MHz，下图是该接口MAC侧发送数据给PHY芯片的时序图。</p> <p><a class=glightbox href=https://pic3.zhimg.com/v2-3fc26898796b73fe40e89ce1654be52a_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt="RGMII TX时序" src=https://pic3.zhimg.com/v2-3fc26898796b73fe40e89ce1654be52a_r.jpg></a></p> <p>MAC侧在时钟TX_CLK的上升沿将需要发送数据的低4位输出到数据线TXD，在时钟TX_CLK下降沿将传输数据的高4位输出到数据线TXD，因此每个时钟传输1字节数据，125MHz的时钟就能实现1000Mbps速率。</p> <p>MAC侧不能直接将TX_CLK输出给PHY芯片使用，因为TX_CLK的上升沿和下降沿对应的TXD信号都处于变化阶段，此时采集数据可能会出错，<strong>TX_CLK周期为8ns，将TX_CLK延迟2ns后输出给PHY芯片作为TX_CLK，延迟后的信号上升沿和下降沿对应的TXD就是稳定的，此时就可以稳定采集数据</strong>。</p> <p>注意TX_CTL信号，该信号将TX_EN和TX_ER结合，在TX_CLK上升沿，TX_CTL输出TX_EN的状态，高电平表示数据有效，在TX_CLK下降沿，此时输出TX_EN异或TX_ER的结果，<strong>所以只有当TX_CTL在TX_CLK上升沿和下降沿同时为高电平时数据才是有效的</strong>。</p> <p>RX_CLK同理，RX相关的时序如下图所示：</p> <p><a class=glightbox href=https://pic3.zhimg.com/v2-40d66c86901bebc9a822d8ef4d9ebb26_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt="RGMII RX时序" src=https://pic3.zhimg.com/v2-40d66c86901bebc9a822d8ef4d9ebb26_r.jpg></a></p> <p>RGMII接口依旧可以实现100Mbps和10Mbps速率传输数据。</p> <ul> <li>当传输速率为100Mbps时，数据位宽为4位，所以时钟频率为25MHz即可。只在时钟上升沿输出数据，但是TX_CTL和RX_CTL依旧需要在上升沿和下降沿传输数据。 </li> <li>当传输速率为10Mbps时，时钟频率为2.5MHz。</li> </ul> </li> </ol> <h3 id=27-can>2.7. CAN<a class=headerlink href=#27-can title="Permanent link">&para;</a></h3> <h3 id=28-dma>2.8. DMA<a class=headerlink href=#28-dma title="Permanent link">&para;</a></h3> <p>DMA的英文拼写是<code>Direct Memory Access</code>，汉语的意思就是直接内存访问，是一种不经过CPU而直接从内存存取数据的数据交换模式。</p> <ul> <li>PIO模式下硬盘和内存之间的数据传输是由CPU来控制的；</li> <li>而在DMA模式下，CPU只须向DMA控制器下达指令，让DMA控制器来处理数的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU资源占有率。</li> </ul> <p><strong>DMA 传送方式的优先级高于程序中断</strong>，两者的区别主要表现在对CPU的干扰程度不同。</p> <ul> <li>中断请求不但使CPU停下来，而且要CPU执行中断服务程序为中断请求服务，这个请求包括了对断点和现场的处理以及CPU与外设的传送，所以CPU付出了很多的代价</li> <li>DMA请求仅仅使CPU暂停一下，不需要对断点和现场的处理，并且是由DMA控制外设与主存之间的数据传送，无需CPU的干预，DMA只是借用了一点CPU的时间而已。</li> <li> <p>CPU对这两个请求的响应时间不同</p> <ul> <li>对中断请求一般都在执行完<code>一条指令的时钟周期末尾响应</code></li> <li>对DMA的请求，由于考虑它的高效性，<strong>CPU在每条指令执行的各个阶段之中都可以让给DMA使用，是立即响应</strong></li> </ul> </li> <li> <p>FIFO【DMA实现原理拓展】</p> <ul> <li>FIFO存储器是一个<code>先入先出</code>的双口缓冲器，即第一个进入其内的数据第一个被移出，其中一个存储器的输入口，另一个口是存储器的输出口。主要有三个方面的作用：<ul> <li>对连续的数据流进行缓存，防止在进机和存储操作时丢失数据</li> <li>数据集中起来进行进机和存储，可避免频繁的总线操作，减轻CPU的负担</li> <li>允许系统进行DMA操作，提高数据的传输速度<ul> <li>这是至关重要的一点，如果不采用DMA操作，数据传输将达不到传输要求，而且大大增加CPU的负担，无法同时完成数据的存储工作。</li> </ul> </li> </ul> </li> <li><a href=https://zhuanlan.zhihu.com/p/656561653>fifo反压机制</a></li> </ul> </li> </ul> <h2 id=3>3. 固件&amp;驱动开发<a class=headerlink href=#3 title="Permanent link">&para;</a></h2> <h3 id=31>3.1. 程序烧录<a class=headerlink href=#31 title="Permanent link">&para;</a></h3> <ol> <li>ICP（In Circuit Programing）在电路编程<ul> <li>使用SWD接口进行烧录，如J-Link烧录器和J-Flash软件配合使用</li> </ul> </li> <li>ISP（In System Programing）在系统编程<ul> <li>使用引导程序（Bootloader）加上UART/USB等外设进行烧录</li> </ul> </li> <li>IAP（In applicating Programing）在应用编程<ul> <li>软件自身实现在线电擦除和编程的方法，不使用任何工具。程序通常分成两块，分别为引导程序和应用程序</li> </ul> </li> </ol> <h3 id=32>3.2. 初始化过程<a class=headerlink href=#32 title="Permanent link">&para;</a></h3> <p>嵌入式系统初始化过程一般分为 3 个过程，自底向上、从硬件到软件的依次为：片级初始化、板级初始化、系统级初始化。</p> <ol> <li> <p>片级初始化</p> <ul> <li>把嵌入式微处理器从上电时的默认状态逐步设置成系统所要求的工作状态，<strong>这是一个纯硬件的初始化过程，完成嵌入式微处理器的初始化</strong>。<ul> <li>包括设置嵌入式微处理器的<code>核心寄存器</code>和<code>控制寄存器</code>、嵌入式微处理器核心工作模式和嵌入式微处理器的局部总线模式等。</li> <li>一般用汇编，这部分基本芯片原厂会提供。</li> </ul> </li> </ul> </li> <li> <p>板级初始化</p> <ul> <li><strong>同时包含软硬件两部分在内的初始化过程</strong>，<code>完成嵌入式微处理器以外的其他硬件设备的初始化</code>，同时设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序的运行建立硬件和软件环境。</li> </ul> </li> <li> <p>系统初始化</p> <ul> <li><strong>该初始化过程以软件初始化为主</strong>，主要进行<code>操作系统的初始化</code>。</li> <li>BSP（Board Support Package）将对嵌入式微处理器的控制权转交给嵌入式操作系统，由操作系统完成余下的初始化操作，包含加载和初始化与硬件无关的设备驱动程序，建立系统内存区，加载并初始化其他系统软件模块，如网络系统、文件系统等。最后，操作系统创建应用程序环境，并将控制权交给应用程序的入口。</li> </ul> </li> </ol> <h3 id=33>3.3. 驱动开发<a class=headerlink href=#33 title="Permanent link">&para;</a></h3> <h2 id=4>4. 操作系统<a class=headerlink href=#4 title="Permanent link">&para;</a></h2> <blockquote> <ol> <li><a href=https://doc.embedfire.com/rtos/freertos/i.mx_rt1052/zh/latest/README.html>野火-FreeRTOS内核实现与应用开发实战指南</a></li> <li><a href=https://www.cnblogs.com/iot-dev/p/11681067.html>FreeRTOS移植参考</a></li> <li><a href=https://jia.je/kb/software/atomic_instructions.html>原子指令</a></li> </ol> </blockquote> <h3 id=40>4.0. 内核对象<a class=headerlink href=#40 title="Permanent link">&para;</a></h3> <p>FreeRTOS 的 <strong>内核对象</strong> 是操作系统提供的核心机制，用于实现任务管理、任务间通信、同步和资源控制。它们是操作系统资源的基本抽象，由内核统一管理和调度。理解内核对象的关键在于以下几点：</p> <hr> <p><strong>1. 内核对象的本质</strong></p> <p>内核对象是 FreeRTOS 内核管理的 <strong>数据结构，每个对象代表一种系统资源（如队列、信号量、任务等）</strong> ，具有以下共同特性：</p> <ul> <li><strong>类型化</strong>：每个对象有明确类型（如队列、信号量、任务等），类型决定了其行为和操作方式。</li> <li><strong>句柄化</strong>：通过 <strong>句柄（Handle）</strong> 访问对象，句柄是一个指针或索引，指向内核对象的内存结构。</li> <li><strong>资源管理</strong>：内核负责对象的创建、删除、调度和内存分配。</li> <li><strong>线程安全</strong>：内核对象的操作（如发送/接收数据）是原子的，由内核保证在多任务环境下的安全性。</li> </ul> <hr> <p><strong>2. 常见内核对象类型</strong></p> <p>FreeRTOS 中主要的内核对象包括：</p> <table> <thead> <tr> <th><strong>内核对象</strong></th> <th><strong>功能描述</strong></th> </tr> </thead> <tbody> <tr> <td><strong>任务（Task）</strong></td> <td>任务控制块（TCB），包含任务状态、优先级、栈指针等信息。</td> </tr> <tr> <td><strong>队列（Queue）</strong></td> <td>任务间传递数据的通道，支持阻塞和非阻塞操作。</td> </tr> <tr> <td><strong>信号量（Semaphore）</strong></td> <td>基于队列实现的同步机制，用于资源计数或事件通知。</td> </tr> <tr> <td><strong>互斥量（Mutex）</strong></td> <td>特殊信号量，支持优先级继承，用于保护共享资源。</td> </tr> <tr> <td><strong>事件组（Event Group）</strong></td> <td>通过位标志实现多任务事件同步，支持“与”和“或”触发逻辑。</td> </tr> <tr> <td><strong>软件定时器（Timer）</strong></td> <td>基于系统时钟的定时器对象，到期后触发回调函数。</td> </tr> <tr> <td><strong>任务通知（Task Notification）</strong></td> <td>轻量级对象，直接嵌入任务控制块（TCB），用于替代信号量或事件组。</td> </tr> </tbody> </table> <hr> <p><strong>3. 内核对象的核心结构</strong></p> <p>所有内核对象在实现上都是 <strong>数据结构</strong>，由 FreeRTOS 内核统一管理。例如：</p> <p><strong>(1) 队列（Queue）的结构</strong></p> <div class=highlight><pre><span></span><code><a id=__codelineno-7-1 name=__codelineno-7-1 href=#__codelineno-7-1></a><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>QueueDefinition</span><span class=w> </span><span class=p>{</span>
<a id=__codelineno-7-2 name=__codelineno-7-2 href=#__codelineno-7-2></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=n>pcHead</span><span class=p>;</span><span class=w>           </span><span class=c1>// 队列存储区起始地址</span>
<a id=__codelineno-7-3 name=__codelineno-7-3 href=#__codelineno-7-3></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=n>pcTail</span><span class=p>;</span><span class=w>           </span><span class=c1>// 队列存储区结束地址</span>
<a id=__codelineno-7-4 name=__codelineno-7-4 href=#__codelineno-7-4></a><span class=w>    </span><span class=k>volatile</span><span class=w> </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxMessagesWaiting</span><span class=p>;</span><span class=w> </span><span class=c1>// 当前队列中的消息数量</span>
<a id=__codelineno-7-5 name=__codelineno-7-5 href=#__codelineno-7-5></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxLength</span><span class=p>;</span><span class=w>     </span><span class=c1>// 队列最大长度（消息数量）</span>
<a id=__codelineno-7-6 name=__codelineno-7-6 href=#__codelineno-7-6></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxItemSize</span><span class=p>;</span><span class=w>   </span><span class=c1>// 每个消息的大小（字节）</span>
<a id=__codelineno-7-7 name=__codelineno-7-7 href=#__codelineno-7-7></a><span class=w>    </span><span class=c1>// ... 其他同步控制字段（如互斥量、阻塞任务列表）</span>
<a id=__codelineno-7-8 name=__codelineno-7-8 href=#__codelineno-7-8></a><span class=p>}</span><span class=w> </span><span class=n>xQUEUE</span><span class=p>;</span>
</code></pre></div> <p><strong>(2) 任务（Task）的结构</strong></p> <p>任务对象通过 <strong>任务控制块（TCB）</strong> 表示：</p> <div class=highlight><pre><span></span><code><a id=__codelineno-8-1 name=__codelineno-8-1 href=#__codelineno-8-1></a><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>tskTaskControlBlock</span><span class=w> </span><span class=p>{</span>
<a id=__codelineno-8-2 name=__codelineno-8-2 href=#__codelineno-8-2></a><span class=w>    </span><span class=k>volatile</span><span class=w> </span><span class=n>StackType_t</span><span class=w> </span><span class=o>*</span><span class=n>pxTopOfStack</span><span class=p>;</span><span class=w>  </span><span class=c1>// 栈顶指针</span>
<a id=__codelineno-8-3 name=__codelineno-8-3 href=#__codelineno-8-3></a><span class=w>    </span><span class=n>ListItem_t</span><span class=w> </span><span class=n>xStateListItem</span><span class=p>;</span><span class=w>           </span><span class=c1>// 任务状态链表项（就绪、阻塞等）</span>
<a id=__codelineno-8-4 name=__codelineno-8-4 href=#__codelineno-8-4></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxPriority</span><span class=p>;</span><span class=w>              </span><span class=c1>// 任务优先级</span>
<a id=__codelineno-8-5 name=__codelineno-8-5 href=#__codelineno-8-5></a><span class=w>    </span><span class=c1>// ... 其他字段（如任务通知值、局部存储指针等）</span>
<a id=__codelineno-8-6 name=__codelineno-8-6 href=#__codelineno-8-6></a><span class=p>}</span><span class=w> </span><span class=n>tskTCB</span><span class=p>;</span>
</code></pre></div> <hr> <p><strong>4. 内核对象的管理机制</strong></p> <p><strong>(1) 创建与删除</strong></p> <ul> <li><strong>动态创建</strong>：通过 API（如<code>xQueueCreate()</code>、<code>xTaskCreate()</code>）在 <strong>堆内存</strong> 中动态分配对象。</li> <li><strong>静态创建</strong>：通过预分配的静态内存（如<code>xQueueCreateStatic()</code>）创建对象，避免动态内存分配。</li> <li><strong>删除</strong>：通过<code>vQueueDelete()</code>、<code>vTaskDelete()</code>等 API 释放对象资源。</li> </ul> <p><strong>(2) 对象句柄</strong></p> <ul> <li>每个对象创建后返回一个 <strong>句柄</strong>（如<code>QueueHandle_t</code>、<code>TaskHandle_t</code>），后续操作需通过句柄访问对象。</li> <li>句柄本质是 <strong>指针</strong>（指向对象数据结构）或 <strong>索引</strong> （在内存池中的位置）。</li> </ul> <p><strong>(3) 同步与阻塞</strong></p> <ul> <li>内核对象操作（如<code>xQueueSend()</code>、<code>xSemaphoreTake()</code>）可能触发 <strong>任务阻塞</strong>，内核会管理任务的阻塞链表。</li> <li>例如，当队列为空时，任务调用<code>xQueueReceive()</code>会被阻塞并挂入队列的阻塞链表，直到有数据到达。</li> </ul> <hr> <p><strong>5. 内核对象的设计特点</strong></p> <p><strong>(1) 轻量化</strong></p> <ul> <li>FreeRTOS 内核对象设计紧凑，避免冗余字段，适合资源受限的嵌入式场景。</li> <li>例如，任务通知直接嵌入任务控制块（TCB），无需额外内存分配。</li> </ul> <p><strong>(2) 基于队列的抽象</strong></p> <ul> <li>许多内核对象（如信号量、互斥量）基于队列实现，减少代码冗余。</li> <li>例如：<ul> <li><strong>二进制信号量</strong>：长度为 1 的队列，数据项大小为 0。</li> <li><strong>互斥量</strong>：在二进制信号量基础上增加优先级继承逻辑。</li> </ul> </li> </ul> <p><strong>(3) 优先级继承</strong></p> <ul> <li>互斥量（Mutex）支持优先级继承，防止优先级反转问题：<ul> <li>当低优先级任务持有互斥量时，若高优先级任务尝试获取，低优先级任务的优先级会被临时提升。</li> </ul> </li> </ul> <hr> <p><strong>6. 内核对象与资源管理</strong></p> <p><strong>(1) 内存分配</strong></p> <ul> <li>动态创建的内核对象使用 FreeRTOS 的堆管理器（如<code>heap_4.c</code>）分配内存。</li> <li>静态创建需用户预分配内存，增强确定性（适合硬实时系统）。</li> </ul> <p><strong>(2) 线程安全</strong></p> <ul> <li>内核对象的操作通过 <strong>临界区保护</strong> 或 <strong>调度器锁</strong> 确保原子性。</li> <li>例如，<code>xQueueSend()</code>在发送数据时会暂时关闭中断或挂起调度器。</li> </ul> <p><strong>(3) 对象所有权</strong></p> <ul> <li>某些对象（如互斥量）具有<code>所有权</code>概念：<ul> <li>只有获取（Take）互斥量的任务才能释放（Give）它。</li> </ul> </li> </ul> <hr> <p><strong>7. 内核对象的使用场景</strong></p> <table> <thead> <tr> <th><strong>对象</strong></th> <th><strong>典型场景</strong></th> </tr> </thead> <tbody> <tr> <td><strong>队列</strong></td> <td>任务间传递结构化数据（如传感器读数、控制命令）。</td> </tr> <tr> <td><strong>互斥量</strong></td> <td>保护共享资源（如全局变量、外设寄存器）。</td> </tr> <tr> <td><strong>事件组</strong></td> <td>多任务等待多个事件组合（如“网络连接成功且数据到达”）。</td> </tr> <tr> <td><strong>任务通知</strong></td> <td>高频轻量级同步（如代替二进制信号量，减少内存开销）。</td> </tr> <tr> <td><strong>软件定时器</strong></td> <td>周期性任务触发（如每 100ms 采集一次数据）。</td> </tr> </tbody> </table> <hr> <p><strong>8. 总结</strong></p> <p>FreeRTOS 的内核对象是操作系统功能的核心载体，理解其本质需关注以下几点：</p> <ol> <li><strong>数据结构</strong>：每个对象是特定类型的结构体，由内核管理。</li> <li><strong>句柄化访问</strong>：通过句柄操作对象，隐藏底层细节。</li> <li><strong>同步与阻塞</strong>：对象操作可能触发任务状态切换（就绪、阻塞等）。</li> <li><strong>资源效率</strong>：设计轻量化，适合嵌入式场景，部分对象（如任务通知）为优化性能而生。</li> </ol> <p>通过合理使用内核对象，开发者可以构建高效、可靠的多任务实时系统。</p> <h3 id=41>4.1. 任务调度<a class=headerlink href=#41 title="Permanent link">&para;</a></h3> <p><strong>任务调度的依赖</strong>：</p> <ol> <li>任务优先级列表，即双向循环列表（每一个列表项都能索引到一个任务控制块）<ul> <li>双向循环列表可以保障任务切换时，每个任务都能轮询<ul> <li>例如，对于freertos来说，存在以下优先级列表 <div class=highlight><pre><span></span><code><a id=__codelineno-9-1 name=__codelineno-9-1 href=#__codelineno-9-1></a><span class=c1>// 可能用到的优先级列表</span>
<a id=__codelineno-9-2 name=__codelineno-9-2 href=#__codelineno-9-2></a><span class=n>pxReadyTasksLists</span><span class=p>[</span><span class=w> </span><span class=n>configMAX_PRIORITIES</span><span class=w> </span><span class=p>]</span><span class=w> </span><span class=c1>// 准备运行状态的任务</span>
<a id=__codelineno-9-3 name=__codelineno-9-3 href=#__codelineno-9-3></a><span class=n>pxDelayedTaskList</span><span class=w> </span><span class=c1>// 阻塞状态的任务</span>
<a id=__codelineno-9-4 name=__codelineno-9-4 href=#__codelineno-9-4></a><span class=n>pxOverflowDelayedTaskList</span><span class=w> </span><span class=c1>// 阻塞状态的任务</span>
<a id=__codelineno-9-5 name=__codelineno-9-5 href=#__codelineno-9-5></a><span class=c1>// 因为调度器挂起，任何被恢复（vTaskResume()）或新创建（xTaskCreate()）的任务</span>
<a id=__codelineno-9-6 name=__codelineno-9-6 href=#__codelineno-9-6></a><span class=c1>// 无法立即加入就绪列表</span>
<a id=__codelineno-9-7 name=__codelineno-9-7 href=#__codelineno-9-7></a><span class=c1>// 这些任务会被临时添加到xPendingReadyList中，等待调度器恢复后处理</span>
<a id=__codelineno-9-8 name=__codelineno-9-8 href=#__codelineno-9-8></a><span class=c1>// 直接操作就绪列表可能导致并发问题（如中断与任务同时修改列表）</span>
<a id=__codelineno-9-9 name=__codelineno-9-9 href=#__codelineno-9-9></a><span class=n>xPendingReadyList</span><span class=w>  </span>
<a id=__codelineno-9-10 name=__codelineno-9-10 href=#__codelineno-9-10></a><span class=n>xSuspendedTaskList</span><span class=w> </span><span class=c1>// 调度器挂起挂起的任务，即处于挂起状态的任务</span>
</code></pre></div></li> <li>任务控制块tskTCB的xStateListItem变量的功能是 <strong>将任务链接到与状态相关的链表中</strong>，直接参与调度器决策，是任务状态管理的核心，<ul> <li>就绪列表（pxReadyTasksLists）：任务处于就绪状态，等待调度</li> <li>阻塞列表（pxDelayedTaskList、pxOverflowDelayedTaskList）：任务因延时或等待资源而挂起</li> <li>挂起列表（xSuspendedTaskList）：任务被显式挂起（vTaskSuspend()）</li> <li>xStateListItem变量可以索引到<code>当前链接的状态链表和任务控制块的首地址</code>，方便任务切换代码的实现</li> </ul> </li> <li>任务控制块tskTCB的xEventListItem变量功能 <strong>将任务链接到与诸如队列、信号量、事件组、任务通知等内核对象因阻塞而设计的延时链表中</strong><ul> <li>是事件同步的桥梁，实现任务对复杂事件条件的等待</li> <li>xEventListItem变量可以索引到<code>当前链接的事件延时链表和任务控制块的首地址</code>，方便事件同步代码的实现</li> </ul> </li> </ul> </li> <li>优先级计算（uxTopReadyPriority）<ul> <li>硬件方法就是使用处理器自带的硬件指令来实现的，比如 Cortex-M 处理器就带有的计算前导0个数指令：CLZ，函数如下： <div class=highlight><pre><span></span><code><a id=__codelineno-10-1 name=__codelineno-10-1 href=#__codelineno-10-1></a><span class=w>    </span><span class=cp>#define taskSELECT_HIGHEST_PRIORITY_TASK()  \</span>
<a id=__codelineno-10-2 name=__codelineno-10-2 href=#__codelineno-10-2></a><span class=cp>    {                       \</span>
<a id=__codelineno-10-3 name=__codelineno-10-3 href=#__codelineno-10-3></a><span class=cp>        UBaseType_t uxTopPriority;  \</span>
<a id=__codelineno-10-4 name=__codelineno-10-4 href=#__codelineno-10-4></a><span class=cp>                        \</span>
<a id=__codelineno-10-5 name=__codelineno-10-5 href=#__codelineno-10-5></a><span class=cp>        </span><span class=c1>//查找包含任务的最高优先级，以前导零的方式查找</span>
<a id=__codelineno-10-6 name=__codelineno-10-6 href=#__codelineno-10-6></a><span class=w>        </span><span class=n>portGET_HIGHEST_PRIORITY</span><span class=p>(</span><span class=w> </span><span class=n>uxTopPriority</span><span class=err>，</span><span class=w> </span><span class=n>uxTopReadyPriority</span><span class=w> </span><span class=p>);</span>
<a id=__codelineno-10-7 name=__codelineno-10-7 href=#__codelineno-10-7></a><span class=w>            </span><span class=n>configASSERT</span><span class=p>(</span><span class=w> </span><span class=n>listCURRENT_LIST_LENGTH</span><span class=p>(</span><span class=w> </span><span class=o>&amp;</span><span class=p>(</span><span class=w> </span><span class=n>pxReadyTasksLists</span><span class=p>[</span><span class=w> </span><span class=n>uxTopPriority</span><span class=w> </span><span class=p>]</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>);</span><span class=w> </span>
<a id=__codelineno-10-8 name=__codelineno-10-8 href=#__codelineno-10-8></a><span class=w>        </span><span class=c1>//通过最高优先级获取就绪任务</span>
<a id=__codelineno-10-9 name=__codelineno-10-9 href=#__codelineno-10-9></a><span class=w>        </span><span class=n>listGET_OWNER_OF_NEXT_ENTRY</span><span class=p>(</span><span class=w> </span><span class=n>pxCurrentTCB</span><span class=err>，</span><span class=w> </span><span class=o>&amp;</span><span class=p>(</span><span class=w> </span><span class=n>pxReadyTasksLists</span><span class=p>[</span><span class=w> </span><span class=n>uxTopPriority</span><span class=w> </span><span class=p>]</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>);</span>
<a id=__codelineno-10-10 name=__codelineno-10-10 href=#__codelineno-10-10></a><span class=w>    </span><span class=p>}</span>
</code></pre></div></li> <li>通 过 函 数 portGET_HIGHEST_PRIORITY() 获取处于就绪态的最高优先级，portGET_HIGHEST_PRIORITY 本质上是个宏，定义如下： <div class=highlight><pre><span></span><code><a id=__codelineno-11-1 name=__codelineno-11-1 href=#__codelineno-11-1></a><span class=w>    </span><span class=cp>#define portGET_HIGHEST_PRIORITY( uxTopPriority， uxReadyPriorities ) </span>
<a id=__codelineno-11-2 name=__codelineno-11-2 href=#__codelineno-11-2></a><span class=w>    </span><span class=p>{</span>
<a id=__codelineno-11-3 name=__codelineno-11-3 href=#__codelineno-11-3></a><span class=w>        </span><span class=n>uxTopPriority</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=mi>31UL</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=kt>uint32_t</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=n>__clz</span><span class=p>(</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>uxReadyPriorities</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>)</span>
<a id=__codelineno-11-4 name=__codelineno-11-4 href=#__codelineno-11-4></a><span class=w>    </span><span class=p>}</span>
</code></pre></div></li> <li>使用硬件方法的时候 <strong>uxTopReadyPriority</strong> 就不代表处于就绪态的最高优先级了，而是使用每个 bit 代表一个优先级，bit0 代表优先级 0，bit31 就代表优先级 31，当某个优先级有就绪任务的话就将其对应的 bit 置 1。</li> <li>从这里就可以看出，如果使用硬件方法的话最多只能有 32 个优先级。__clz(uxReadyPriorities)就是计算 <strong>uxReadyPriorities</strong>（unsigned long）的前导零个数，前导零个数就是指从最高位开始(bit31)到第一个为 1 的 bit，其间 0 的个数。如下例子：二进制数 1000 0000 0000 0000 的前导零个数就为 0。 二进制数 0000 1001 1111 0001 的前导零个数就是 4。</li> <li>得到 uxTopReadyPriority 的前导零个数以后在用 31 减去这个前导零个数得到的就是处于就绪态的最高优先级了，比如优先级 30 为此时的处于就绪态的最高优先级，30 的前导零个数为 1，那么 31 - 1 = 30，得到处于就绪态的最高优先级为 30。</li> </ul> </li> </ul> </li> <li>任务控制块</li> <li>任务的堆栈段</li> <li>启动首次任务的SVC中断</li> <li>PendSV中断（触发上下文转换）和SYSTICK中断（会间接触发PendSV中断）<ul> <li>CPU上下文维护（即CPU相关寄存器的维护）</li> <li>任务上下文（任务堆栈段的维护）</li> <li>PendSV_Handler是用于每次任务切换中断（由SYSTICK中断或者任务主动触发）</li> <li>SysTick_Handler是一个定时器回调函数</li> </ul> </li> </ol> <hr> <p><strong>任务调度分配</strong>：</p> <ul> <li>IRQ 任务：IRQ 任务是指通过中断服务程序进行触发的任务，此类任务应该设置为所有任务里面优先级最高的。</li> <li>高优先级后台任务：比如按键检测，触摸检测，USB 消息处理，串口消息处理等，都可以归为这一类任务。</li> <li>低优先级的时间片调度任务：比如界面显示，LED 数码管的显示等不需要实时执行的都可以归为这一类任务。 实际应用中用户不必拘泥于将这些任务都设置为优先级 1 的同优先级任务，可以设置多个优先级，只需注意这类任务不需要高实时性。</li> <li>空闲任务：空闲任务是系统任务。</li> <li>特别注意：<strong>IRQ 任务和高优先级任务必须设置为阻塞式</strong>，只有这样，高优先级任务才会释放 CPU 的使用权，从而低优先级任务才有机会得到执行。</li> </ul> <p>参考文档：</p> <ul> <li>https://zhuanlan.zhihu.com/p/554825433</li> <li>https://o2ospring.github.io/20210615/</li> <li>https://blog.csdn.net/weixin_55672545/article/details/130453893</li> </ul> <h3 id=42>4.2. 消息队列、信号量、互斥量、事件组、任务通知和软件定时器之间的关系<a class=headerlink href=#42 title="Permanent link">&para;</a></h3> <p>FreeRTOS 中的消息队列、信号量、互斥量、事件组、任务通知和软件定时器是操作系统提供的多种核心机制，用于实现任务间通信、同步和资源管理。它们之间存在层次化的关系，部分机制基于其他机制实现，同时在不同场景下互补协作。以下是它们的详细关系和对比分析：</p> <hr> <p><strong>1. 底层实现关系</strong></p> <p><strong>(1) 消息队列（Queue）是基础</strong></p> <ul> <li><strong>消息队列</strong> 是 FreeRTOS 中最底层的通信机制，其他高级机制（如信号量、互斥量）均基于消息队列实现。</li> <li><strong>实现方式</strong>：<br> 信号量和互斥量通过长度为 1 的队列实现。例如：<ul> <li><strong>二进制信号量</strong>：队列中存放空消息（无实际数据）。</li> <li><strong>互斥量（Mutex）</strong>：特殊的二进制信号量，支持优先级继承。</li> <li><strong>计数信号量</strong>：队列长度大于 1，记录可用资源数量。</li> </ul> </li> </ul> <p><strong>(2) 任务通知（Task Notification）是轻量级替代</strong></p> <ul> <li><strong>任务通知</strong> 直接操作任务的控制块（TCB），无需创建独立内核对象，因此更高效。</li> <li><strong>功能覆盖</strong>：<ul> <li>可模拟二进制信号量、事件标志组等，但不能传递数据（需配合全局变量）。</li> </ul> </li> </ul> <hr> <p><strong>2. 功能对比与协作</strong></p> <p><strong>(1) 数据传递 vs 同步控制</strong></p> <table> <thead> <tr> <th>机制</th> <th>数据传递</th> <th>同步控制</th> <th>资源管理</th> <th>适用场景</th> </tr> </thead> <tbody> <tr> <td><strong>消息队列</strong></td> <td>✔️</td> <td>✔️</td> <td>❌</td> <td>任务间传递结构化数据</td> </tr> <tr> <td><strong>信号量</strong></td> <td>❌</td> <td>✔️</td> <td>✔️</td> <td>资源计数、任务同步</td> </tr> <tr> <td><strong>互斥量</strong></td> <td>❌</td> <td>✔️</td> <td>✔️</td> <td>保护共享资源（优先级继承）</td> </tr> <tr> <td><strong>事件组</strong></td> <td>❌</td> <td>✔️</td> <td>❌</td> <td>多事件组合触发</td> </tr> <tr> <td><strong>任务通知</strong></td> <td>❌</td> <td>✔️</td> <td>✔️</td> <td>轻量级同步（替代信号量/事件）</td> </tr> <tr> <td><strong>软件定时器</strong></td> <td>❌</td> <td>✔️</td> <td>❌</td> <td>定时触发回调或同步任务</td> </tr> </tbody> </table> <p><strong>(2) 协作场景示例</strong></p> <ul> <li><strong>定时器 + 任务通知</strong>： </li> </ul> <p>软件定时器到期后，通过任务通知唤醒任务处理事件。</p> <ul> <li><strong>事件组 + 信号量</strong>： </li> </ul> <p>多个事件（如网络数据到达、传感器触发）通过事件组组合，触发信号量通知任务。</p> <ul> <li><strong>互斥量 + 队列</strong>： </li> </ul> <p>保护共享资源（如队列）的访问，避免多任务竞争。</p> <hr> <p><strong>3. 层次化架构</strong></p> <div class=highlight><pre><span></span><code><a id=__codelineno-12-1 name=__codelineno-12-1 href=#__codelineno-12-1></a>FreeRTOS 内核
<a id=__codelineno-12-2 name=__codelineno-12-2 href=#__codelineno-12-2></a>├── 消息队列（Queue） → 基础通信机制
<a id=__codelineno-12-3 name=__codelineno-12-3 href=#__codelineno-12-3></a>│   ├── 二进制信号量（Binary Semaphore）
<a id=__codelineno-12-4 name=__codelineno-12-4 href=#__codelineno-12-4></a>│   ├── 计数信号量（Counting Semaphore）
<a id=__codelineno-12-5 name=__codelineno-12-5 href=#__codelineno-12-5></a>│   └── 互斥量（Mutex） → 支持优先级继承的二进制信号量
<a id=__codelineno-12-6 name=__codelineno-12-6 href=#__codelineno-12-6></a>├── 事件组（Event Group） → 独立的事件标志位管理
<a id=__codelineno-12-7 name=__codelineno-12-7 href=#__codelineno-12-7></a>├── 任务通知（Task Notification） → 轻量级替代信号量/事件组
<a id=__codelineno-12-8 name=__codelineno-12-8 href=#__codelineno-12-8></a>└── 软件定时器（Software Timer） → 基于 Tick 中断，与任务同步协作
</code></pre></div> <hr> <p><strong>4. 关键区别与选择建议</strong></p> <table> <thead> <tr> <th>特性</th> <th>资源占用</th> <th>实时性</th> <th>功能复杂度</th> <th>适用场景</th> </tr> </thead> <tbody> <tr> <td><strong>消息队列</strong></td> <td>高</td> <td>中</td> <td>支持数据传递</td> <td>复杂数据传输（如传感器数据）</td> </tr> <tr> <td><strong>任务通知</strong></td> <td>极低</td> <td>高</td> <td>仅同步/简单状态传递</td> <td>高频轻量同步（替代信号量）</td> </tr> <tr> <td><strong>事件组</strong></td> <td>中</td> <td>中</td> <td>多事件组合触发</td> <td>多条件协同触发（如 AND/OR）</td> </tr> <tr> <td><strong>软件定时器</strong></td> <td>中</td> <td>依赖配置</td> <td>定时任务触发</td> <td>周期性任务（如数据采集）</td> </tr> </tbody> </table> <hr> <p><strong>5. 总结</strong></p> <ul> <li><strong>消息队列</strong> 是核心基础设施，其他同步机制（信号量、互斥量）基于其实现。</li> <li><strong>任务通知</strong> 是轻量级替代方案，适合高频同步场景，但功能有限。</li> <li><strong>事件组</strong> 和 <strong>软件定时器</strong> 提供特定场景的优化支持（多事件组合、定时触发）。</li> <li>实际开发中需根据 <strong>实时性要求</strong> 、 <strong>资源开销</strong> 和 <strong>功能需求</strong> 综合选择机制。</li> </ul> <p>通过合理组合这些机制，可以构建高效、可维护的实时多任务系统。</p> <h4 id=421>4.2.1. 信号量、消息队列<a class=headerlink href=#421 title="Permanent link">&para;</a></h4> <ol> <li> <p><strong>所有的队列操作，均会开启临界区关闭中断！！！</strong></p> </li> <li> <p><code>队列</code>是实时操作系统主要的任务间通讯方式。</p> <ul> <li>可以在任务与任务间、中断和任务间传送信息</li> <li>发送到队列的消息是通过拷贝实现的，这意味着队列存储的数据是原数据，而不是原数据的引用</li> </ul> </li> <li> <p>队列发送或接收过程中会挂起调度器，通过挂起调度器而非依赖硬件原子指令或关闭中断，实现了队列操作的高效原子性保护。</p> <ul> <li>这种设计在 <strong>单核嵌入式系统</strong> 中平衡了实时性、代码可移植性及性能开销，成为其广泛应用的基石</li> <li>对于多核或超大规模系统，需结合其他同步机制（如自旋锁）</li> </ul> <p><strong>一、确保数据操作的原子性</strong></p> <p>队列操作涉及对共享数据结构（如队列头尾指针、消息计数器）的修改，挂起调度器可防止任务切换导致的 <strong>中间状态不一致</strong>。例如：</p> <ul> <li><strong>写入队列</strong>：若在修改队列尾指针时发生任务切换，其他任务可能读取到未完全更新的指针，导致数据错乱。</li> <li><strong>读取队列</strong>：任务在取出消息时，若未及时更新队列头指针，其他任务可能误判队列状态。</li> </ul> <p>通过挂起调度器，确保当前任务独占队列访问权，直到操作完成。</p> <hr> <p><strong>二、避免优先级反转与死锁</strong></p> <p>队列操作常伴随任务阻塞（如队列满时等待），挂起调度器可 <strong>安全管理阻塞队列</strong>：</p> <ol> <li> <p><strong>阻塞列表操作</strong> </p> <p>当任务因队列满/空需阻塞时，需将其加入等待列表。若此时发生任务切换，新任务可能修改同一队列，导致等待列表被破坏。</p> </li> <li> <p><strong>唤醒逻辑安全</strong> </p> <p>其他任务或中断释放队列空间时，需唤醒等待任务。挂起调度器确保唤醒操作与队列状态修改的原子性，避免遗漏唤醒或重复唤醒。</p> </li> </ol> <hr> <p><strong>三、优化中断处理兼容性</strong></p> <p>FreeRTOS采用 <strong>分层临界区保护策略</strong>：</p> <ul> <li><strong>挂起调度器</strong>：仅禁止任务切换，中断仍可触发（ISR可继续操作队列）。</li> <li><strong>关闭中断</strong>：完全阻止任务切换和中断响应，代价更高。</li> </ul> <p>在队列操作中挂起调度器而非关闭中断，允许中断服务程序（ISR）继续运行，减少系统延迟，同时保证任务级操作的原子性。</p> <hr> <p><strong>四、性能与实时性平衡</strong></p> <ol> <li> <p><strong>低开销操作</strong> </p> <p>挂起/恢复调度器仅涉及修改调度器状态变量（如 <code>uxSchedulerSuspended</code>），无上下文切换开销，适用于高频调用的队列操作。</p> </li> <li> <p><strong>减少临界区时间</strong> </p> <p>相比关闭中断，挂起调度器的临界区更短，对实时性影响更小，尤其适合多任务频繁通信的场景。</p> </li> </ol> <hr> <p><strong>五、对比其他同步机制</strong></p> <table> <thead> <tr> <th><strong>机制</strong></th> <th><strong>适用场景</strong></th> <th><strong>队列操作中的局限性</strong></th> </tr> </thead> <tbody> <tr> <td><strong>互斥量</strong></td> <td>保护长期持有的资源</td> <td>可能引发优先级反转或递归调用</td> </tr> <tr> <td><strong>信号量</strong></td> <td>简单计数同步</td> <td>无法直接保护队列数据结构完整性</td> </tr> <tr> <td><strong>关闭中断</strong></td> <td>极短临界区（如寄存器操作）</td> <td>中断延迟高，破坏系统实时性</td> </tr> <tr> <td><strong>挂起调度器</strong></td> <td>短时任务级原子操作</td> <td>平衡性能与安全性，最适合队列</td> </tr> </tbody> </table> <hr> <p><strong>六、实现流程示例（以<code>xQueueSend()</code>为例）</strong></p> <ol> <li> <p><strong>挂起调度器</strong> </p> <div class=highlight><pre><span></span><code><a id=__codelineno-13-1 name=__codelineno-13-1 href=#__codelineno-13-1></a><span class=n>taskENTER_CRITICAL</span><span class=p>();</span><span class=w>  </span><span class=c1>// 通过挂起调度器进入临界区</span>
</code></pre></div> </li> <li> <p><strong>检查队列状态</strong> </p> <ul> <li>若队列未满，直接写入数据并更新指针。</li> <li>若队列已满，将当前任务加入等待发送列表。</li> </ul> </li> <li> <p><strong>恢复调度器</strong> </p> <div class=highlight><pre><span></span><code><a id=__codelineno-14-1 name=__codelineno-14-1 href=#__codelineno-14-1></a><span class=n>taskEXIT_CRITICAL</span><span class=p>();</span><span class=w>   </span><span class=c1>// 恢复调度器，必要时触发任务切换</span>
</code></pre></div> </li> <li> <p><strong>唤醒等待任务</strong> </p> <p>若有任务在等待接收，且队列中有数据，唤醒最高优先级任务。</p> </li> </ol> <hr> <p><strong>七、设计权衡与适用性</strong></p> <ul> <li> <p><strong>优势</strong>：</p> <ul> <li>兼容所有架构，无需硬件原子指令支持。 </li> <li>中断响应延迟低，适合实时性要求高的场景。 </li> </ul> </li> <li> <p><strong>局限性</strong>：</p> <ul> <li>挂起期间无法处理任务优先级变化，需确保临界区极短。 </li> <li>不适用于多核系统（FreeRTOS主要针对单核设计）。</li> </ul> </li> </ul> </li> </ol> <hr> <div class=highlight><pre><span></span><code><a id=__codelineno-15-1 name=__codelineno-15-1 href=#__codelineno-15-1></a><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>QueuePointers</span>
<a id=__codelineno-15-2 name=__codelineno-15-2 href=#__codelineno-15-2></a><span class=p>{</span>
<a id=__codelineno-15-3 name=__codelineno-15-3 href=#__codelineno-15-3></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>pcTail</span><span class=p>;</span><span class=w>     </span><span class=c1>// 队列尾地址</span>
<a id=__codelineno-15-4 name=__codelineno-15-4 href=#__codelineno-15-4></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>pcReadFrom</span><span class=p>;</span><span class=w> </span><span class=c1>// 队列首地址</span>
<a id=__codelineno-15-5 name=__codelineno-15-5 href=#__codelineno-15-5></a><span class=p>}</span><span class=w> </span><span class=n>QueuePointers_t</span><span class=p>;</span>
<a id=__codelineno-15-6 name=__codelineno-15-6 href=#__codelineno-15-6></a>
<a id=__codelineno-15-7 name=__codelineno-15-7 href=#__codelineno-15-7></a><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>SemaphoreData</span>
<a id=__codelineno-15-8 name=__codelineno-15-8 href=#__codelineno-15-8></a><span class=p>{</span>
<a id=__codelineno-15-9 name=__codelineno-15-9 href=#__codelineno-15-9></a><span class=w>    </span><span class=n>TaskHandle_t</span><span class=w> </span><span class=n>xMutexHolder</span><span class=p>;</span><span class=w>        </span><span class=c1>// TCB句柄</span>
<a id=__codelineno-15-10 name=__codelineno-15-10 href=#__codelineno-15-10></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxRecursiveCallCount</span><span class=p>;</span><span class=w> </span><span class=c1>// 当用作递归互斥量的时候用来记录递归互斥量被调用的次数</span>
<a id=__codelineno-15-11 name=__codelineno-15-11 href=#__codelineno-15-11></a><span class=p>}</span><span class=w> </span><span class=n>SemaphoreData_t</span><span class=p>;</span>
<a id=__codelineno-15-12 name=__codelineno-15-12 href=#__codelineno-15-12></a>
<a id=__codelineno-15-13 name=__codelineno-15-13 href=#__codelineno-15-13></a><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>QueueDefinition</span>
<a id=__codelineno-15-14 name=__codelineno-15-14 href=#__codelineno-15-14></a><span class=p>{</span>
<a id=__codelineno-15-15 name=__codelineno-15-15 href=#__codelineno-15-15></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=n>pcHead</span><span class=p>;</span><span class=w>    </span><span class=c1>// 指向队列存储区开始地址</span>
<a id=__codelineno-15-16 name=__codelineno-15-16 href=#__codelineno-15-16></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=n>pcTail</span><span class=p>;</span><span class=w>    </span><span class=c1>// 指向队列存储区最后一个字节</span>
<a id=__codelineno-15-17 name=__codelineno-15-17 href=#__codelineno-15-17></a><span class=w>    </span><span class=kt>int8_t</span><span class=w> </span><span class=o>*</span><span class=n>pcWriteTo</span><span class=p>;</span><span class=w> </span><span class=c1>// 指向存储区中下一个空闲区域</span>
<a id=__codelineno-15-18 name=__codelineno-15-18 href=#__codelineno-15-18></a>
<a id=__codelineno-15-19 name=__codelineno-15-19 href=#__codelineno-15-19></a><span class=w>    </span><span class=k>union</span>
<a id=__codelineno-15-20 name=__codelineno-15-20 href=#__codelineno-15-20></a><span class=w>    </span><span class=p>{</span>
<a id=__codelineno-15-21 name=__codelineno-15-21 href=#__codelineno-15-21></a><span class=w>        </span><span class=n>QueuePointers_t</span><span class=w> </span><span class=n>xQueue</span><span class=p>;</span><span class=w>     </span><span class=c1>// 队列信息</span>
<a id=__codelineno-15-22 name=__codelineno-15-22 href=#__codelineno-15-22></a><span class=w>        </span><span class=n>SemaphoreData_t</span><span class=w> </span><span class=n>xSemaphore</span><span class=p>;</span><span class=w> </span><span class=c1>// 信号量信息</span>
<a id=__codelineno-15-23 name=__codelineno-15-23 href=#__codelineno-15-23></a><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=n>u</span><span class=p>;</span>
<a id=__codelineno-15-24 name=__codelineno-15-24 href=#__codelineno-15-24></a>
<a id=__codelineno-15-25 name=__codelineno-15-25 href=#__codelineno-15-25></a><span class=w>    </span><span class=n>List_t</span><span class=w> </span><span class=n>xTasksWaitingToSend</span><span class=p>;</span><span class=w>    </span><span class=c1>// 等待发送任务列表，那些因为队列满导致入队失败而进入阻塞态的任务就会挂在这个列表上</span>
<a id=__codelineno-15-26 name=__codelineno-15-26 href=#__codelineno-15-26></a><span class=w>    </span><span class=n>List_t</span><span class=w> </span><span class=n>xTasksWaitingToReceive</span><span class=p>;</span><span class=w> </span><span class=c1>// 等待接受任务列表，那些因为队列空导致出队失败而进入阻塞态的任务就会挂到此列表上</span>
<a id=__codelineno-15-27 name=__codelineno-15-27 href=#__codelineno-15-27></a>
<a id=__codelineno-15-28 name=__codelineno-15-28 href=#__codelineno-15-28></a><span class=w>    </span><span class=k>volatile</span><span class=w> </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxMessagesWaiting</span><span class=p>;</span><span class=w> </span><span class=c1>// 队列中当前消息数量</span>
<a id=__codelineno-15-29 name=__codelineno-15-29 href=#__codelineno-15-29></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxLength</span><span class=p>;</span><span class=w>                   </span><span class=c1>// 创建队列时指定的队列长度，也就是队列中最大允许的队列项数量</span>
<a id=__codelineno-15-30 name=__codelineno-15-30 href=#__codelineno-15-30></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxItemSize</span><span class=p>;</span><span class=w>                 </span><span class=c1>// 创建队列时指定的每个队列项最大长度，单位字节</span>
<a id=__codelineno-15-31 name=__codelineno-15-31 href=#__codelineno-15-31></a>
<a id=__codelineno-15-32 name=__codelineno-15-32 href=#__codelineno-15-32></a><span class=w>    </span><span class=k>volatile</span><span class=w> </span><span class=kt>int8_t</span><span class=w> </span><span class=n>cRxLock</span><span class=p>;</span><span class=w> </span><span class=c1>// 当队列上锁以后用来统计从队列中接收到的队列项数量，也就是出队的队列项数量</span>
<a id=__codelineno-15-33 name=__codelineno-15-33 href=#__codelineno-15-33></a><span class=w>    </span><span class=k>volatile</span><span class=w> </span><span class=kt>int8_t</span><span class=w> </span><span class=n>cTxLock</span><span class=p>;</span><span class=w> </span><span class=c1>// 当队列上锁以后用来统计发送到队列中的队列项数量，也就是入队的队列项数量</span>
<a id=__codelineno-15-34 name=__codelineno-15-34 href=#__codelineno-15-34></a>
<a id=__codelineno-15-35 name=__codelineno-15-35 href=#__codelineno-15-35></a><span class=cp>#if ((configSUPPORT_STATIC_ALLOCATION == 1) &amp;&amp; (configSUPPORT_DYNAMIC_ALLOCATION == 1))</span>
<a id=__codelineno-15-36 name=__codelineno-15-36 href=#__codelineno-15-36></a><span class=w>    </span><span class=kt>uint8_t</span><span class=w> </span><span class=n>ucStaticallyAllocated</span><span class=p>;</span><span class=w> </span><span class=c1>// 如果使用静态存储的话此字段设置为pdTURE</span>
<a id=__codelineno-15-37 name=__codelineno-15-37 href=#__codelineno-15-37></a><span class=cp>#endif</span>
<a id=__codelineno-15-38 name=__codelineno-15-38 href=#__codelineno-15-38></a>
<a id=__codelineno-15-39 name=__codelineno-15-39 href=#__codelineno-15-39></a><span class=cp>#if (configUSE_TRACE_FACILITY == 1) </span><span class=c1>// 跟踪调试相关宏</span>
<a id=__codelineno-15-40 name=__codelineno-15-40 href=#__codelineno-15-40></a><span class=w>    </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxQueueNumber</span><span class=p>;</span>
<a id=__codelineno-15-41 name=__codelineno-15-41 href=#__codelineno-15-41></a><span class=w>    </span><span class=kt>uint8_t</span><span class=w> </span><span class=n>ucQueueType</span><span class=p>;</span>
<a id=__codelineno-15-42 name=__codelineno-15-42 href=#__codelineno-15-42></a><span class=cp>#endif</span>
<a id=__codelineno-15-43 name=__codelineno-15-43 href=#__codelineno-15-43></a>
<a id=__codelineno-15-44 name=__codelineno-15-44 href=#__codelineno-15-44></a><span class=p>}</span><span class=w> </span><span class=n>xQUEUE</span><span class=p>;</span>
<a id=__codelineno-15-45 name=__codelineno-15-45 href=#__codelineno-15-45></a><span class=k>typedef</span><span class=w> </span><span class=n>xQUEUE</span><span class=w> </span><span class=n>Queue_t</span><span class=p>;</span>
</code></pre></div> <p><strong>消息队列结构体：</strong></p> <p><a class=glightbox href=https://pic3.zhimg.com/v2-ecf600002fe4e38e03a3277256f81f72_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic3.zhimg.com/v2-ecf600002fe4e38e03a3277256f81f72_r.jpg alt=消息队列结构体 style="width: 40%; height: 40%;"></a></p> <div class=highlight><pre><span></span><code><a id=__codelineno-16-1 name=__codelineno-16-1 href=#__codelineno-16-1></a><span class=c1>// 队列初始化API</span>
<a id=__codelineno-16-2 name=__codelineno-16-2 href=#__codelineno-16-2></a><span class=n>xQueueCreate</span><span class=p>(</span><span class=n>uxQueueLength</span><span class=err>，</span><span class=w> </span><span class=n>uxItemSize</span><span class=p>)</span>
<a id=__codelineno-16-3 name=__codelineno-16-3 href=#__codelineno-16-3></a><span class=cp>#define xQueueCreate(uxQueueLength， uxItemSize)   xQueueGenericCreate((uxQueueLength)， (uxItemSize)， (queueQUEUE_TYPE_BASE))</span>
<a id=__codelineno-16-4 name=__codelineno-16-4 href=#__codelineno-16-4></a><span class=n>QueueHandle_t</span><span class=w> </span><span class=n>xQueueGenericCreate</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxQueueLength</span><span class=err>，</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>UBaseType_t</span><span class=w> </span><span class=n>uxItemSize</span><span class=err>，</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>uint8_t</span><span class=w> </span><span class=n>ucQueueType</span><span class=p>)</span>
<a id=__codelineno-16-5 name=__codelineno-16-5 href=#__codelineno-16-5></a><span class=c1>// uxQueueLength：队列项数目</span>
<a id=__codelineno-16-6 name=__codelineno-16-6 href=#__codelineno-16-6></a><span class=c1>// uxItemSize：每个队列项的大小</span>
<a id=__codelineno-16-7 name=__codelineno-16-7 href=#__codelineno-16-7></a><span class=c1>// pucQueueStorage：使用静态分配队列时才使用，指向定义队列存储空间，如果使用动态分配队列空间（默认），向这个参数传递NULL。</span>
<a id=__codelineno-16-8 name=__codelineno-16-8 href=#__codelineno-16-8></a><span class=c1>// pxStaticQueue：使用静态分配队列时才使用，指向队列控制结构体，如果使用动态分配队列空间（默认），向这个参数传递NULL。</span>
<a id=__codelineno-16-9 name=__codelineno-16-9 href=#__codelineno-16-9></a><span class=c1>// ucQueueType：类型，可视化跟踪调试用。可能的值为：</span>
<a id=__codelineno-16-10 name=__codelineno-16-10 href=#__codelineno-16-10></a><span class=c1>//         queueQUEUE_TYPE_BASE：表示队列</span>
<a id=__codelineno-16-11 name=__codelineno-16-11 href=#__codelineno-16-11></a><span class=c1>//         queueQUEUE_TYPE_SET：表示队列集合</span>
<a id=__codelineno-16-12 name=__codelineno-16-12 href=#__codelineno-16-12></a><span class=c1>//         queueQUEUE_TYPE_MUTEX：表示互斥量</span>
<a id=__codelineno-16-13 name=__codelineno-16-13 href=#__codelineno-16-13></a><span class=c1>//         queueQUEUE_TYPE_COUNTING_SEMAPHORE：表示计数信号量</span>
<a id=__codelineno-16-14 name=__codelineno-16-14 href=#__codelineno-16-14></a><span class=c1>//         queueQUEUE_TYPE_BINARY_SEMAPHORE：表示二进制信号量</span>
<a id=__codelineno-16-15 name=__codelineno-16-15 href=#__codelineno-16-15></a><span class=c1>//         queueQUEUE_TYPE_RECURSIVE_MUTEX ：表示递归互斥量</span>
<a id=__codelineno-16-16 name=__codelineno-16-16 href=#__codelineno-16-16></a><span class=n>BaseType_t</span><span class=w> </span><span class=n>xQueueGenericSend</span><span class=p>(</span><span class=n>QueueHandle_t</span><span class=w> </span><span class=n>xQueue</span><span class=err>，</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=n>pvItemToQueue</span><span class=err>，</span>
<a id=__codelineno-16-17 name=__codelineno-16-17 href=#__codelineno-16-17></a><span class=w>                             </span><span class=n>TickType_t</span><span class=w> </span><span class=n>xTicksToWait</span><span class=err>，</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>BaseType_t</span><span class=w> </span><span class=n>xCopyPosition</span><span class=p>)</span>
<a id=__codelineno-16-18 name=__codelineno-16-18 href=#__codelineno-16-18></a><span class=c1>// xQueue：队列句柄</span>
<a id=__codelineno-16-19 name=__codelineno-16-19 href=#__codelineno-16-19></a><span class=c1>// pvItemToQueue：指针，指向要入队的列表项</span>
<a id=__codelineno-16-20 name=__codelineno-16-20 href=#__codelineno-16-20></a><span class=c1>// xTicksToWait：时间单位为系统节拍时钟周期，宏portTICK_PERIOD_MS可以用来辅助计算真实延时值。</span>
<a id=__codelineno-16-21 name=__codelineno-16-21 href=#__codelineno-16-21></a><span class=c1>//               如果队列满，等待队列空闲的最大时间，</span>
<a id=__codelineno-16-22 name=__codelineno-16-22 href=#__codelineno-16-22></a><span class=c1>//               如果队列满并且xTicksToWait被设置成0，函数立刻返回，</span>
<a id=__codelineno-16-23 name=__codelineno-16-23 href=#__codelineno-16-23></a><span class=c1>//               如果INCLUDE_vTaskSuspend设置成1，并且指定延时为portMAX_DELAY将引起任务无限阻塞（没有超时）。</span>
<a id=__codelineno-16-24 name=__codelineno-16-24 href=#__codelineno-16-24></a><span class=c1>// xCopyPosition：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队。</span>
</code></pre></div> <p><strong>执行流程：</strong></p> <p><a class=glightbox href=../image/message_transfer_flow.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/message_transfer_flow.png alt=消息发送流程 style="width: 50%; height: 50%;"></a></p> <ol> <li>当任务将数据入队时，如果队列未满或者以覆盖式入队，调用函数prvCopyDataToQueue()将要入队的数据拷贝到队列。这个函数处理三种入队情况，<ul> <li>第一种是队列项大小为零时（即队列结构体成员uxItemSize为0，比如二进制信号量和计数信号量），不进行数据拷贝工作，而是将队列项计数器加1（即队列结构体成员uxMessagesWaiting++）；</li> <li>第二种情况是从队列尾入队时，则将数据拷贝到指针pxQueue-&gt;pcWriteTo指向的地方、更新指针指向的位置、队列项计数器加1；</li> <li>第三种情况是从队列首入队时，则将数据拷贝到指针pxQueue-&gt;u.pcReadFrom指向的地方、更新指针指向的位置、队列项计数器加1。如果是覆盖式入队，还会调整队列项计数器的值。</li> </ul> </li> <li>完成数据入队操作后，还要检查是否有任务因为等待出队而阻塞，因为这次数据入队，队列至少有一个队列项，如果有阻塞任务，则阻塞的最高优先级任务可以解除阻塞了。<ul> <li>因等待出队而阻塞的任务会将任务的事件列表项（即任务TCB结构体成员xEventListItem，它是任务TCB的一个结构体成员）挂接到队列的等待出队列表上（即队列结构体成员xTasksWaitingToReceive）。</li> <li>因为要解除任务阻塞，我们需要将任务的事件列表项从队列的等待出队队列上删除，并且将任务移动到就绪列表中。这一切，都是调用函数xTaskRemoveFromEventList()实现的。</li> </ul> </li> <li>如果解除阻塞的任务优先级比当前任务优先级更高，则触发一个PendSV中断，等退出临界区后，进行上下文切换。入队任务完成。</li> <li>如果任务入队时，队列满并且不允许覆盖入队：<ul> <li>阻塞时间为0的情况。设置阻塞时间为0意味着当队列满时，函数立即返回，返回一个错误代码，表示队列满。</li> <li>阻塞时间不为0，则本任务会因为等待入队而进入阻塞。<ul> <li>在将任务设置为阻塞的过程中，是不希望有其它任务和中断操作这个队列的事件列表的（队列结构体成员xTasksWaitingToReceive列表和xTasksWaitingToSend列表），<strong>因为操作队列事件列表可能引起其它任务解除阻塞，这可能会发生优先级翻转</strong>。<ul> <li>比如任务A的优先级低于本任务，但是在本任务进入阻塞的过程中，任务A却因为其它原因解除阻塞了，这显然是要绝对禁止的。因此FreeRTOS使用挂起调度器来简单粗暴的禁止其它任务操作队列，因为挂起调度器意味着任务不能切换并且不准调用可能引起任务切换的API函数。</li> <li><strong>但挂起调度器并不会禁止中断，中断服务函数仍然可以操作队列事件列表，可能会解除任务阻塞、可能会进行上下文切换，这是不允许的</strong>。于是，解决办法是<code>不但挂起调度器，还要给队列上锁！</code><ul> <li>队列结构体中有两个成员跟队列上锁有关：xRxLock和xTxLock。<ul> <li>两个成员变量为queueUNLOCKED（宏，定义为-1）时，表示队列未上锁；</li> <li>两个成员变量为queueLOCKED_UNMODIFIED（宏，定义为0）时，表示队列上锁。</li> </ul> </li> <li>队列上锁是调用宏prvLockQueue()实现的，代码很简单，将队列结构体成员xRxLock和xTxLock都设置为queueLOCKED_UNMODIFIED。</li> <li>队列上锁是如何起作用的？<ul> <li>当中断服务程序（xQueueCRReceiveFromISR或xQueueCRSendFromISR函数）操作队列并且导致阻塞的任务解除阻塞时，会首先判断该队列是否上锁，<strong>如果没有上锁，则解除被阻塞的任务，还会根据需要设置上下文切换请求标志</strong>；</li> <li>如果队列已经上锁，则不会解除被阻塞的任务，取而代之的是，将xRxLock或xTxLock加1，<strong>表示队列上锁期间出队或入队的数目，也表示有任务可以解除阻塞了</strong>。</li> </ul> </li> <li>函数prvUnlockQueue()用于解除队列锁，将可以解除阻塞的任务插入到就绪列表，解除任务的最大数量由xRxLock和xTxLock指定。</li> </ul> </li> </ul> </li> <li>经过一系列的逻辑判断，发现本任务还是要进入阻塞状态，则调用函数vTaskPlaceOnEventList()来实现。<ul> <li>第一步，将任务的事件列表项（任务TCB结构体成员xEventListItem）<strong>插入到队列的等待入队列表（队列结构体成员xTasksWaitingToSend）中</strong>；</li> <li>第二步，将任务的状态列表项（任务TCB结构体成员xStateListItem）从就绪列表中删除，然后插入到延时列表中，<code>任务的最大延时时间放入xStateListItem.xItemValue</code>中，每次系统节拍定时器中断服务函数中，都会检查这个值，检测任务是否超时。</li> </ul> </li> <li>当任务成功阻塞在等待入队操作后，当前任务就没有必要再占用CPU了，所以接下来解除队列锁、恢复调度器、进行任务切换，下一个处于最高优先级的就绪任务就会被运行了。</li> </ul> </li> </ul> </li> <li>注意的细节：<ul> <li>队列的xTasksWaitingToSend、 xTasksWaitingToReceive都是添加到pxDelayedTaskList和pxOverflowDelayedTaskList队列，非<code>xSuspendedTaskList、xPendingReadyList、pxReadyTasksLists队列</code></li> <li>发送队列消息时，处理xTasksWaitingToReceive列表</li> <li>接收队列消息时，处理xTasksWaitingToReceive列表</li> </ul> </li> </ol> <hr> <p><strong>信号量</strong></p> <p>一般用来进行资源管理和任务间、任务与中断间的同步，FreeRTOS 中的信号量分为二值信号量、计数型信号量、互斥信号量和递归互斥信号量。</p> <ul> <li><strong>信号量创建调用的底层API跟队列创建是同一个</strong>，只是传入参数不同</li> <li>这四种信号量的句柄类型是相同的SemaphoreHandle_t，本质上是队列句柄QueueHandle_t</li> </ul> <div class=highlight><pre><span></span><code><a id=__codelineno-17-1 name=__codelineno-17-1 href=#__codelineno-17-1></a><span class=k>typedef</span><span class=w> </span><span class=n>QueueHandle_t</span><span class=w> </span><span class=n>SemaphoreHandle_t</span><span class=p>;</span>
</code></pre></div> <ol> <li> <p>二值信号量</p> <ul> <li>实质上是一个队列长度为 1，队列项长度为 0 的队列</li> <li>没有队列项存储区，通过队列结构体的成员 uxMessageWaiting来判断队列是否为空</li> <li>二值信号量创建后是无效的，必须先调用API释放，才能使用</li> <li>二值信号量的释放就是向队列中发送消息，但消息为NULL，阻塞时间为0，后向入队。关键在于入队的时候，队列结构体成员 uxMessageWaiting 会加一，从而判断队列时满1还是空0。</li> </ul> <div class=highlight><pre><span></span><code><a id=__codelineno-18-1 name=__codelineno-18-1 href=#__codelineno-18-1></a><span class=c1>// API 功能</span>
<a id=__codelineno-18-2 name=__codelineno-18-2 href=#__codelineno-18-2></a><span class=n>xSemaphoreCreateBinary</span><span class=p>()</span><span class=w>           </span><span class=c1>// 动态创建二值信号量</span>
<a id=__codelineno-18-3 name=__codelineno-18-3 href=#__codelineno-18-3></a><span class=n>xSemaphoreCreateBinaryStatic</span><span class=p>()</span><span class=w> </span><span class=c1>// 静态创建二值信号量</span>
<a id=__codelineno-18-4 name=__codelineno-18-4 href=#__codelineno-18-4></a>
<a id=__codelineno-18-5 name=__codelineno-18-5 href=#__codelineno-18-5></a><span class=n>xSemaphoreGive</span><span class=p>()</span><span class=w>        </span><span class=c1>// 任务级释放二值信号量</span>
<a id=__codelineno-18-6 name=__codelineno-18-6 href=#__codelineno-18-6></a><span class=n>xSemaphoreGiveFromISR</span><span class=p>()</span><span class=w> </span><span class=c1>// 中断级释放信号量</span>
<a id=__codelineno-18-7 name=__codelineno-18-7 href=#__codelineno-18-7></a><span class=n>xSemaphoreTake</span><span class=p>()</span><span class=w>        </span><span class=c1>// 任务级获取信号量</span>
<a id=__codelineno-18-8 name=__codelineno-18-8 href=#__codelineno-18-8></a><span class=n>xSemaphoreTakeFromISR</span><span class=p>()</span><span class=w> </span><span class=c1>// 中断级获取信号量</span>
<a id=__codelineno-18-9 name=__codelineno-18-9 href=#__codelineno-18-9></a><span class=n>vSemaphoreDelete</span><span class=p>()</span><span class=w>      </span><span class=c1>// 删除信号量</span>
<a id=__codelineno-18-10 name=__codelineno-18-10 href=#__codelineno-18-10></a>
<a id=__codelineno-18-11 name=__codelineno-18-11 href=#__codelineno-18-11></a><span class=c1>// 获取二值信号量可以设置阻塞时间，读取成功后 uxMessageWaiting 会减一</span>
<a id=__codelineno-18-12 name=__codelineno-18-12 href=#__codelineno-18-12></a><span class=cp>#define xSemaphoreTake( xSemaphore， xBlockTime )    xQueueSemaphoreTake( ( xSemaphore )， ( xBlockTime ) )</span>
</code></pre></div> </li> <li> <p>计数型信号量</p> <ul> <li>队列长度大于1，队列项长度为0</li> <li>同样通过队列结构体成员 uxMessageWaiting来判断数量</li> <li>计数型信号量的释放、获取与删除操作与二值信号量相同</li> </ul> <div class=highlight><pre><span></span><code><a id=__codelineno-19-1 name=__codelineno-19-1 href=#__codelineno-19-1></a><span class=c1>// API  功能</span>
<a id=__codelineno-19-2 name=__codelineno-19-2 href=#__codelineno-19-2></a><span class=n>xSemaphoreCreateCounting</span><span class=p>()</span><span class=w>       </span><span class=c1>// 动态创建计数型信号量</span>
<a id=__codelineno-19-3 name=__codelineno-19-3 href=#__codelineno-19-3></a><span class=n>xSemaphoreCreateCountingStatic</span><span class=p>()</span><span class=w> </span><span class=c1>// 静态创建计数型信号量</span>
<a id=__codelineno-19-4 name=__codelineno-19-4 href=#__codelineno-19-4></a><span class=cp>#define xSemaphoreCreateCounting(uxMaxCount， uxInitialCount) \</span>
<a id=__codelineno-19-5 name=__codelineno-19-5 href=#__codelineno-19-5></a><span class=cp>xQueueCreateCountingSemaphore((uxMaxCount)， (uxInitialCount))</span>
</code></pre></div> </li> <li> <p>互斥信号量</p> <ul> <li>互斥量具有优先级继承机制，<strong>只能用在任务中，不能用于中断服务函数</strong></li> <li>中断服务函数不能因为要等待互斥量而设置阻塞时间进入阻塞态</li> <li>队列长度为1，队列项长度为0</li> <li>任务在使用完互斥量后必须释放，否则其他资源无法使用，即互斥量是一个不能被销毁的特殊信号量</li> </ul> <div class=highlight><pre><span></span><code><a id=__codelineno-20-1 name=__codelineno-20-1 href=#__codelineno-20-1></a><span class=c1>// API  功能</span>
<a id=__codelineno-20-2 name=__codelineno-20-2 href=#__codelineno-20-2></a><span class=n>xSemaphoreCreateMutex</span><span class=p>()</span><span class=w>           </span><span class=c1>// 动态创建互斥信号量</span>
<a id=__codelineno-20-3 name=__codelineno-20-3 href=#__codelineno-20-3></a><span class=n>xSemaphoreCreateMutexStatic</span><span class=p>()</span><span class=w> </span><span class=c1>// 静态创建互斥信号量</span>
</code></pre></div> <ul> <li>互斥信号量获取和释放的过程与二值信号量有些区别，<strong>主要涉及到优先级继承</strong></li> <li> <p>优先级翻转</p> <ul> <li><strong>互斥信号量是防止出现优先级翻转导致卡死的情况</strong><ul> <li>针对于一个公共资源被多个任务调用的情况下</li> </ul> </li> <li><strong>优先级翻转主要发生在当两个任务H和L共用一个信号量时</strong>，</li> <li>当信号量为二值型时，L优先获得信号量后，会将H的优先级拉低到和自身相同，使得M任务抢先于H执行，出现优先级翻转（未解决了优先级反转）</li> <li>当信号量为互斥型时，L优先获得信号量后，H会将L的优先级拉高到和自身相同，尽量避免优先级翻转（解决了优先级反转）</li> </ul> <p><a class=glightbox href=../image/priority_reverse.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/priority_reverse.png alt=优先级翻转 style="width: 60%; height: 60%;"></a></p> </li> </ul> </li> <li> <p>总结</p> <table> <thead> <tr> <th style="text-align: center;">通讯方式</th> <th style="text-align: center;">长度</th> <th style="text-align: center;">约束</th> <th style="text-align: left;">作用</th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">队列-值传递</td> <td style="text-align: center;">&gt;0</td> <td style="text-align: center;">阻塞读写</td> <td style="text-align: left;">用于任务之间传递数据</td> </tr> <tr> <td style="text-align: center;">二值信号量</td> <td style="text-align: center;">1</td> <td style="text-align: center;">一方只需要申请，另一方只需要释放</td> <td style="text-align: left;">用于锁存1个中断代表资源的到达/用于任务的异步通知</td> </tr> <tr> <td style="text-align: center;">计数型信号量</td> <td style="text-align: center;">&gt;1</td> <td style="text-align: center;">一方只需要申请，另一方只需要释放</td> <td style="text-align: left;">用于锁存若干个中断以免中断丢失/用于同步代表资源的数量</td> </tr> <tr> <td style="text-align: center;">互斥信号量</td> <td style="text-align: center;">1</td> <td style="text-align: center;">申请的一方必须自己进行释放</td> <td style="text-align: left;">用于互斥访问机制</td> </tr> </tbody> </table> </li> </ol> <h4 id=422>4.2.2. 事件组<a class=headerlink href=#422 title="Permanent link">&para;</a></h4> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/320664678>FreeRTOS源码探析之——事件标志组</a></li> </ol> </blockquote> <ol> <li> <p>事件组概念</p> <p>事件组通常是由一组位（bits）组成的数据结构，其中每一位都对应着某个特定的事件。每个位可以被设置或清除，表示相应的事件发生或未发生。这种位的组合形成了一个类似于二进制数的集合，每个位都代表着某个特定的状态或事件。<strong>因此，可以将事件组视为由一系列二进制位构成的数据结构，每个位代表着一个独立的事件状态。</strong></p> <p>事件组中的每一位可以表示一个特定的事件或状态，任务可以根据这些事件或状态来进行相应的处理。<strong>通过设置或清除这些位，可以触发或取消相应的事件处理逻辑</strong>。事件组的位通常用于指示某些事件是否发生、是否完成或是否需要进一步处理。这种灵活性使得事件组成为一种强大的工具，用于任务间的同步、通信和协作。</p> <p>在使用事件组时，可以通过操作单独的位来表示不同的事件或状态，从而实现复杂的任务管理和事件处理。通过适当地设置和清除位，可以实现任务间的协同工作，以满足特定的应用需求。事件组的这种位级别的控制使其成为处理任务间通信和同步的有效工具。</p> <ul> <li> <p>事件组的位数：</p> <ul> <li> <p>如果 configUSE_16_BIT_TICKS 被设置为 1（启用），则事件组有16位，其中最高的8位（从最高位到第9位）用于内核管理，而剩下的低8位留给用户自定义事件。</p> </li> <li> <p>如果 configUSE_16_BIT_TICKS 被设置为 0（禁用），则事件组有32位，其中最高的8位（从最高位到第25位）用于内核管理，而剩下的低24位留给用户自定义事件。</p> </li> </ul> </li> </ul> <p><a class=glightbox href=../image/event_group.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/event_group.png alt=事件组示意 style="width: 60%; height: 60%;"></a></p> </li> <li> <p>事件组和信号量，队列的区别</p> <ol> <li> <p>事件组（Event Group）：</p> <p>概念：事件组是由多个位组成的数据结构，用于表示多个事件的状态。任务可以等待事件组中的特定位或位组合被设置，从而实现任务同步。</p> <p>用途：事件组常用于任务间的事件通知和同步。任务可以等待多个事件中的任意一个或多个同时发生，或者等待所有事件都发生后再继续执行。</p> <p>特点：事件组允许任务等待多个事件，提供了更灵活的同步机制。</p> </li> <li> <p>信号量（Semaphore）：</p> <p>概念：信号量是一个计数器，用于控制多个任务对共享资源的访问。信号量的值表示可用资源的数量，任务可以请求或释放资源，信号量负责追踪可用资源的数量。</p> <p>用途：信号量常用于控制共享资源的访问，防止多个任务同时访问共享资源，以避免竞争条件（Race Condition）。</p> <p>特点：信号量是一个计数器，可以用于控制资源的数量和分配。</p> </li> <li> <p>队列（Queue）：</p> <p>概念：队列是一个数据结构，用于在任务间传递数据。任务可以将数据发送到队列，另一个任务则可以从队列中接收这些数据。</p> <p>用途：队列常用于任务间的数据传递，允许任务异步地发送和接收数据，实现解耦和通信。</p> <p>特点：队列是一个数据缓冲区，可以用于存储和传递数据，任务间的数据传递是异步的。</p> </li> <li> <p><strong>区别总结</strong>：</p> <p>事件组用于任务间的事件通知和同步，<strong>任务可以等待多个事件的发生</strong>。</p> <p>信号量用于控制对共享资源的访问，<strong>防止多个任务同时访问资源</strong>。</p> <p>队列用于任务间的数据传递，<strong>任务可以异步地发送和接收数据</strong>。</p> </li> </ol> </li> </ol> <h4 id=423>4.2.3. 软件定时器<a class=headerlink href=#423 title="Permanent link">&para;</a></h4> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/305853273>FreeRTOS源码探析之——软件定时器</a></li> <li><a href=https://blog.csdn.net/luliplus/article/details/121152401>FreeRTOS基础五：软件定时器</a></li> </ol> </blockquote> <p>软件定时器的作用：<strong>在指定的时间到来时执行指定的函数，或者以某个频率周期性地执行某个函数。被执行的函数叫做软件定时器回调函数。</strong></p> <p>软件定时器由FreeRTOS内核实现，不需要硬件支持。软件定时器只有在软件定时器回调函数被调用时才需要占用CPU时间。</p> <p>在FreeRTOS应用程序中使用软件定时器，则需要：</p> <ul> <li> <p>将软件定时器的源码（FreeRTOS/Source/timers.c）添加到项目中</p> </li> <li> <p>在FreeRTOSConfig.h中定义configUSE_TIMERS为1</p> <ul> <li>软件定时器任务的任务优先级和栈深度是在FreeRTOSConfig.h中通过configTIMER_TASK_PRIORITY和configTIMER_TASK_STACK_DEPTH这两个宏配置的。</li> <li>软件定时器命令队列的长度在FreeRTOSConfig.h中使用configTIMER_QUEUE_LENGTH来定义。</li> </ul> </li> </ul> <p>【注意】</p> <ul> <li>软件定时器回调函数是在软件定时器任务中被执行的，<strong>软件定时器任务是在vTaskStartScheduler()函数内部由内核自动创建的</strong>。<ul> <li>当调用vTaskStartScheduler()来开启调度器后，这个函数内部使用xTimerCreateTimerTask()来创建软件定时器任务。</li> </ul> </li> <li>不要在回调函数中使用一些 <strong>导致任务阻塞的函数或代码</strong>，<strong>例如vTaskDelay()，否则会导致FreeRTOS后台任务进入到阻塞状态。</strong></li> <li>定时器任务通常使用一个叫做 xTimerList 的链表进行管理，每个定时器都有一个到期时间戳（通常是系统滴答时间加上定时器的延迟时间）。<strong>链表按到期时间排序，确保每次唤醒时，系统都能处理即将到期的定时器任务</strong><ul> <li>需要注意的是任务阻塞维护的pxDelayedTaskList链表是不排序的，切换任务过程中，遍历列表，处理超时的任务</li> </ul> </li> </ul> <p><strong>软件定时器的相关API本质上是<code>操作队列的API</code></strong>。</p> <ul> <li>当FreeRTOS调度器启动时，内核除了自动创建软件定时器任务外，<strong>还会自动创建一个软件定时器命令队列</strong>。</li> <li>在用户任务中使用软件定时器相关的API，例如启动定时器，停止定时器，复位定时器，<strong>本质上就是通过这个队列来向软件定时器任务发送相关消息</strong>。</li> </ul> <p><strong>所以软件定时器大部分情况下阻塞状态</strong>，只有当用户发送了一个软件定时器命令或者一个软件定时器定时器到期需要执行回调函数时，才会被唤醒进入就绪状态。</p> <p>那么为什么说不能在定时器回调函数中使用让软件定时器阻塞的代码呢？</p> <ul> <li>因为软件定时器任务的状态只应该由内核或者定时器API来控制而不能由用户代码控制，这样才能保证软件定时器的能正常使用。</li> </ul> <p><a class=glightbox href=../image/software_timer.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=软件定时器 src=../image/software_timer.png></a></p> <h3 id=43>4.3. 锁<a class=headerlink href=#43 title="Permanent link">&para;</a></h3> <p>在执行代码时，有的代码开始执行，是不允许被打断的，<strong>这部分的代码也叫作临界段代码</strong>，这种临界区保护的做法也叫锁机制。</p> <ul> <li>FreeRTOS 主要用于 <strong>单核嵌入式系统，关闭中断即可有效保证原子性</strong>，故通过开关中断来实现锁机制<ul> <li>若用原子指令实现锁机制，部分低性能的硬件不支持，<code>不满足FreeRTOS以最小复杂度覆盖最大硬件范围，同时满足实时性需求的理念</code></li> <li>FreeRTOS 的临界区通常极短（如操作链表、计数器增减），关闭中断的代价可接受</li> </ul> </li> </ul> <p>FreeRTOS可以认为存在三种锁机制：调度锁、中断锁、互斥锁：</p> <ol> <li> <p>中断锁</p> <p>顾名思义，中断锁的意思是防止程序进行中断切换，即不允许被其他中断打断</p> <p><strong>重要函数如下:</strong></p> <div class=highlight><pre><span></span><code><a id=__codelineno-21-1 name=__codelineno-21-1 href=#__codelineno-21-1></a><span class=c1>// portENTER_CRITICAL() 和portEXIT_CRITICAL() 函数必须是成对调用</span>
<a id=__codelineno-21-2 name=__codelineno-21-2 href=#__codelineno-21-2></a><span class=c1>// portDISABLE_INTERRUPTS() 和portENABLE_INTERRUPTS() 是可以不成对出现的</span>
<a id=__codelineno-21-3 name=__codelineno-21-3 href=#__codelineno-21-3></a><span class=cp>#define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() </span><span class=c1>// 进临界区</span>
<a id=__codelineno-21-4 name=__codelineno-21-4 href=#__codelineno-21-4></a><span class=cp>#define portENABLE_INTERRUPTS() vPortSetBASEPRI(0)   </span><span class=c1>// 退出临界区</span>
<a id=__codelineno-21-5 name=__codelineno-21-5 href=#__codelineno-21-5></a>
<a id=__codelineno-21-6 name=__codelineno-21-6 href=#__codelineno-21-6></a><span class=cp>#define portENTER_CRITICAL() vPortEnterCritical() </span><span class=c1>// 进临界区</span>
<a id=__codelineno-21-7 name=__codelineno-21-7 href=#__codelineno-21-7></a><span class=cp>#define portEXIT_CRITICAL() vPortExitCritical()   </span><span class=c1>// 退出临界区</span>
<a id=__codelineno-21-8 name=__codelineno-21-8 href=#__codelineno-21-8></a>
<a id=__codelineno-21-9 name=__codelineno-21-9 href=#__codelineno-21-9></a><span class=cp>#define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI()  </span><span class=c1>// 进临界区</span>
<a id=__codelineno-21-10 name=__codelineno-21-10 href=#__codelineno-21-10></a><span class=cp>#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) </span><span class=c1>// 退出临界区</span>
<a id=__codelineno-21-11 name=__codelineno-21-11 href=#__codelineno-21-11></a>
<a id=__codelineno-21-12 name=__codelineno-21-12 href=#__codelineno-21-12></a><span class=c1>// 【basepri寄存器】如果向basepri寄存器写0的话，就会停止中断屏蔽，</span>
<a id=__codelineno-21-13 name=__codelineno-21-13 href=#__codelineno-21-13></a><span class=c1>// 如果要屏蔽优先级不高于xx的中断，则可以将该优先级传给这个参数。</span>
<a id=__codelineno-21-14 name=__codelineno-21-14 href=#__codelineno-21-14></a><span class=c1>// 若配置的参数为configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY值为4，</span>
<a id=__codelineno-21-15 name=__codelineno-21-15 href=#__codelineno-21-15></a><span class=c1>// 则表示屏蔽优先级不高于4的中断。即屏蔽PenSV和systick中断。</span>
<a id=__codelineno-21-16 name=__codelineno-21-16 href=#__codelineno-21-16></a><span class=cp>#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    0x4</span>
</code></pre></div> </li> <li> <p>调度锁</p> <ul> <li> <p>调度锁的意思是防止程序进行上下文切换。当有一些数据是不允许上下文切换的话，就可以通过调度锁来保证</p> <p>重要的函数如下：</p> <div class=highlight><pre><span></span><code><a id=__codelineno-22-1 name=__codelineno-22-1 href=#__codelineno-22-1></a><span class=n>vTaskSuspendAll</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span><span class=w> </span><span class=c1>// 开启调度锁（不允许调度）</span>
<a id=__codelineno-22-2 name=__codelineno-22-2 href=#__codelineno-22-2></a><span class=n>xTaskResumeAll</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span><span class=w>  </span><span class=c1>// 关闭调度锁（允许调度）</span>
<a id=__codelineno-22-3 name=__codelineno-22-3 href=#__codelineno-22-3></a><span class=c1>// vTaskSuspendAll和xTaskResumeAll内部会维护一个变量xTaskResumeAll，</span>
<a id=__codelineno-22-4 name=__codelineno-22-4 href=#__codelineno-22-4></a><span class=c1>// 挂起自增，调度则自减</span>
<a id=__codelineno-22-5 name=__codelineno-22-5 href=#__codelineno-22-5></a><span class=c1>// 上下文切换时会先检查一下变量uxSchedulerSuspended，</span>
<a id=__codelineno-22-6 name=__codelineno-22-6 href=#__codelineno-22-6></a><span class=c1>// 如果该变量为非零。则表示当前不允许进行任务切换</span>
</code></pre></div> </li> <li> <p><strong>另外，调度锁只是禁止了调度器工作，并没有关闭任何中断</strong></p> </li> </ul> </li> <li> <p>互斥锁</p> <ul> <li> <p>当程序在访问某些共享数据的时候，可能会出现同时改变共享资源的情况</p> <ul> <li>这种情况可能会造成程序运行出现异常</li> <li>为了防止这种情况出现，增加了互斥锁的概念 </li> </ul> </li> <li> <p><strong>互斥锁是依靠互斥信号量来实现的</strong></p> </li> </ul> </li> </ol> <h3 id=44>4.4. 空闲任务与钩子函数<a class=headerlink href=#44 title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://blog.csdn.net/qq_51963216/article/details/122788392>空闲任务及钩子函数</a></li> </ol> </blockquote> <h3 id=45>4.5. 空闲任务的钩子函数与协程（已抛弃）<a class=headerlink href=#45 title="Permanent link">&para;</a></h3> <blockquote> <ol> <li><a href=https://elmagnifico.tech/2017/03/23/FreeRTOS-croutine-Interpretation/ >FreeRTOS中croutine源文件分析</a></li> <li><a href=https://www.bookstack.cn/read/freeRTOS_Document/%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%8D%8F%E7%A8%8B-%E5%8D%8F%E7%A8%8B.md>协程</a></li> </ol> </blockquote> <h2 id=5>5. 协议<a class=headerlink href=#5 title="Permanent link">&para;</a></h2> <h3 id=51>5.1. 以太网协议栈<a class=headerlink href=#51 title="Permanent link">&para;</a></h3> <ol> <li>物理层：在设备之间传输比特流，规定了电平、速度和电缆针脚。</li> <li>数据链路层：将比特组合成字节，再将字节组合成帧，使用链路层地址(以太网使用MAC地址)来访问介质，并进行差错检测。</li> <li>网络层：提供逻辑地址，供路由器确定路径。</li> <li>传输层：提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。</li> <li>会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</li> <li>表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</li> <li>应用层：OS参考模型中最靠近用户的一层，为应用程序提供网络服务。</li> </ol> <p><a class=glightbox href=https://pic4.zhimg.com/v2-7a087008746d376d2c601a2b053770c7_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic4.zhimg.com/v2-7a087008746d376d2c601a2b053770c7_r.jpg alt=以太网协议栈 style="width: 70%; height: 70%;"></a></p> <p><a class=glightbox href=../image/eth_protocol_stack.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/eth_protocol_stack.jpg alt=以太网协议栈 style="width: 70%; height: 70%;"></a></p> <p><a class=glightbox href=https://pic2.zhimg.com/v2-1dd6e1ed2f348db47ce0cde38d545ae9_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic2.zhimg.com/v2-1dd6e1ed2f348db47ce0cde38d545ae9_r.jpg alt=以太网协议栈 style="width: 70%; height: 70%;"></a></p> <h4 id=511>5.1.1. 物理层<a class=headerlink href=#511 title="Permanent link">&para;</a></h4> <p><a class=glightbox href=../image/phy_protocol_stack.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/phy_protocol_stack.png alt=物理层协议栈 style="width: 60%; height: 60%;"></a></p> <p>物理层大致可以分为</p> <ul> <li>xMII介质无关接口</li> <li>PCS物理编码子层<ul> <li>信道编码</li> </ul> </li> <li>PMA物理介质连接层<ul> <li>实现了串并转换</li> </ul> </li> <li>PMD物理介质相关层<ul> <li>负责将串行信号转到相应的物理介质上</li> </ul> </li> <li>MDI接口<ul> <li>MDI就是连接PHY芯片和物理介质的接口，常见的是RJ45接口<ul> <li>百兆网时，四根线，两对差分信号，只用了RJ45接口的 1，2，3，6线</li> <li>千兆网时， 共8根线，四对差分信号， 用了RJ45接口的8根线（RJ45接口总共8根线）</li> </ul> </li> <li>RJ45接口上的两个灯<ul> <li>绿灯：长亮，表示链路完整</li> <li>黄灯：闪烁，表示有数据收发</li> </ul> </li> </ul> </li> <li> <p>MEDIUM物理介质</p> <ul> <li>即网线或光纤</li> </ul> </li> <li> <p>自协商 Auto_negotiation</p> <ul> <li> <p>自协商一般是在物理层完成的。但是具体在PHY的哪一层完成，由具体物理介质规范决定。基本原理就是将自协商的信息通过一串脉冲序列发送出去，这串脉冲称为FLP。这串脉冲的特点如下。脉冲中分为时钟脉冲和数据脉冲，数据脉冲夹在时钟脉冲中间，第一个脉冲为时钟脉冲，数据脉冲中正脉冲表示1，无脉冲表示0.一个FLP脉冲序列包含17个时钟脉冲，16个数据脉冲。时钟脉冲每个125us出现一次。</p> </li> <li> <p><a class=glightbox href=../image/Auto_negotiation.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=自协商 src=../image/Auto_negotiation.png></a></p> </li> </ul> </li> <li> <p>IEEE 802.3标准根据使用的传输线缆和传输线路的不同，有10BASE-T、10BASE-TX，具体的命名规则如下:</p> <p><a class=glightbox href=../image/IEEE_802_3_standard.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=IEEE_802_3_standard src=../image/IEEE_802_3_standard.png></a></p> <ol> <li>数据速率 (R)：<ul> <li>1000 → 1000 Mbps或1 Gbps</li> <li>10G → 10 Gbps</li> <li>10/1G → Gbps下行，1 Gbps上行</li> </ul> </li> <li>调制类型 (mTYPE)：BASE → 基带</li> <li>介质类型/波长/距离 (L)：<ul> <li>B → 双向光纤，上行(D) 或上行 (U) 限定符不对称</li> <li>C → 双轴铜缆</li> <li>D → 并行单模 (500 m)</li> <li>E → 超长光波长λ (1510/1550 nm) / 距离 (40 km)</li> <li>F → 光纤 (2 km)</li> <li>K → 背板</li> <li>L → 长光波长λ (~1310 nm) / 距离 (10 km)</li> <li>P → 无源光纤，带有单个或多个下游 (D) 或上游 (U) 不对称限定符，而且带有4B/5B或8B/10B的外部来源编码 (X)</li> <li>RH → 采用PAM16编码的红色LED塑料光纤和不同发射功率的光纤</li> <li>S → 短光波长λ (850 nm) / 距离 (100 m)</li> <li>T → 双绞线</li> </ul> </li> <li>PCS编码 (C)：<ul> <li>R → 扰码 (64B/66B)</li> <li>X → 外部来源编码 (4B/5B， 8B/10B)</li> </ul> </li> <li>通道数 (n)：<ul> <li>空白，无通道数 → 默认为1通道</li> <li>4 → 4通道</li> </ul> </li> </ol> </li> </ul> <blockquote> <ol> <li><a href=https://www.cnblogs.com/yousun/p/8639919.html>以太网之物理层参考文档</a></li> <li><a href=https://cloud.tencent.com/developer/article/1653117>以太网之物理层参考文档</a></li> <li><a href=https://zhuanlan.zhihu.com/p/552415999>物理层工作原理</a></li> </ol> </blockquote> <h4 id=512>5.1.2. 数据链路层<a class=headerlink href=#512 title="Permanent link">&para;</a></h4> <p>以太网常用帧格式有两种， 一种是Ethernet II，另一种是IEEE 802.3 格式。</p> <ul> <li>802.3 是IEEE的正式标准，它由Ethernet Ethernet II发展而来</li> <li> <p>Ethernet II中包含一个Type字段，描述了以太网首部后面所跟数据包的类型，标识以太帧处理完成之后将被发送到哪个上层协议进行处理；而IEEE 802.3格式中同样的位置是长度字段。</p> <ul> <li><strong>从Type/Length字段值可以区分两种帧类型：当Type字段值小于等于1500（0x05DC）时，帧使用的是IEEE 802.3格式。当Type字段值大于等于1536（0x0600）时，帧使用的是Ethernet II格式</strong></li> <li>LLC只出现在802.3以太网的格式中，802.3的MAC层没有字段指明上层协议字段，但是指明了数据包长度，所以上层协议需要LLC指明。在Ethernet II帧中，把802.3的长度字段改为了type。由Type字段区分上层协议，这时候就没有必要实现LLC子层，仅包含一个MAC子层。</li> </ul> </li> <li> <p>以太网帧格式多达5种，事实上，今天的大多数TCP/IP应用都是用Ethernet V2帧格式，而交换机之间的BPDU数据包是IEEE802.3/LLC的帧，VLAN Trunk协议如802.1Q和Cisco的CDP等则是采用IEEE802.3/SNAP的帧。</p> </li> <li> <p>据RFC894的说明，以太网封装的数据部分(Payload)的最大长度是1500Byte【称为以太网的最大传输单元(MTU)，注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度】，在这个限制之下，最长的以太帧包括6字节的目的地址(DMAC)、6字节的源地址(SMAC)、2字节的以太类型(EtherType)、1500字节的数据(Payload)、4字节的校验(FCS)，总共是1518字节。<strong>但是实际上我们抓包得到的最大帧是1514字节，为什么不是1518字节呢？</strong> </p> <ul> <li>原因是当数据帧到达网卡时，在物理层上网卡要先去掉前导同步码和帧开始定界符，然后对帧进行CRC检验，如果帧校验和错，就丢弃此帧。如果校验和正确，就判断帧的目的硬件地址是否符合自己的接收条件（目的地址是自己的物理硬件地址、广播地址、可接收的多播硬件地址等），如果符合，就将帧交<code>设备驱动程序</code>做进一步处理。这时我们的抓包软件才能抓到数据， 因此，抓包软件抓到的是去掉前导码、帧开始分界符、FCS之外的数据，其最大值是6＋6＋2＋1500＝1514字节。</li> </ul> </li> </ul> <p><a class=glightbox href=../image/link_protocol_stack.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/link_protocol_stack.png alt=数据链路层协议栈 style="width: 80%; height: 80%;"></a></p> <hr> <p><a class=glightbox href=https://pic1.zhimg.com/v2-bed783f99f6904b00962ba7f49ffbd37_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic1.zhimg.com/v2-bed783f99f6904b00962ba7f49ffbd37_r.jpg alt=数据链路层帧格式 style="width: 60%; height: 60%;"></a></p> <p>以太网帧的三种传输模式：</p> <ol> <li> <p>单播</p> <ul> <li>指从单一的源端发送到单一的目的端。在冲突域中，所有主机都能收到源主机发送的单播帧，但是其他主机发现目的地址与本地MAC地址不一致后会丢弃收到的帧，只有真正的目的主机才会接收并处理收到的帧。</li> </ul> <p><a class=glightbox href=https://picx.zhimg.com/v2-bec3792b4708235d2016118814e549e5_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://picx.zhimg.com/v2-bec3792b4708235d2016118814e549e5_r.jpg alt=单播 style="width: 60%; height: 60%;"></a></p> </li> <li> <p>广播</p> <ul> <li>表示帧从单一的源发送到共享以大网上的所有主机。广播帧的目的MAC地址为十六进制的FF:FF:FF:FF:FF:FF，所有收到该广播帧的主机都要接收并处理这个帧。广播方式会产生大量流量，导致带宽利用率降低，进而影响整个网络的性能。当需要网络中的所有主机都能接收到相同的信息并进行处理的情况下，通常会使用广播方式。</li> </ul> <p><a class=glightbox href=https://pic1.zhimg.com/v2-f61de4fc31aad916d98f3b4ce2aeb43e_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pic1.zhimg.com/v2-f61de4fc31aad916d98f3b4ce2aeb43e_r.jpg alt=广播 style="width: 60%; height: 60%;"></a></p> </li> <li> <p>组播</p> <ul> <li>组播转发可以理解为选择性的广播，主机侦听特定组播地址，接收并处理目的AC地址为该组播MAC地址的帧。组播MAC地址和单播MAC地址是通过第一字节中的第8个比特区分的。组播MAC地址的第8个比特为1，而单播MAC地址的第8个比特为0。当需要网络上的一组主机（而不是全部主机）接收相同信息，并且其他主机不受影响的情况下通常会使用组播方式。</li> </ul> <p><a class=glightbox href=https://pica.zhimg.com/v2-b5fdce911d8cd48bfcd147c54811edfd_r.jpg data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=https://pica.zhimg.com/v2-b5fdce911d8cd48bfcd147c54811edfd_r.jpg alt=组播 style="width: 60%; height: 60%;"></a></p> </li> </ol> <hr> <p><strong>VLAN（Virtual Local Area Network）</strong></p> <p>VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。 每个VLAN是一个广播域，VLAN内的主机间可以直接通信，而VLAN间则不能直接互通。这样，广播报文就被限制在一个VLAN内。</p> <p><a class=glightbox href=../image/vlan.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/vlan.png alt=VLAN的作用 style="width: 60%; height: 60%;"></a></p> <p>要使交换机能够分辨不同VLAN的报文，需要在报文中添加标识VLAN信息的字段。IEEE 802.1Q协议规定，在以太网数据帧中加入4个字节的VLAN标签（又称VLAN Tag，简称Tag），用以标识VLAN信息。</p> <p><a class=glightbox href=../image/vlan_tag.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/vlan_tag.png alt=VLAN报文 style="width: 60%; height: 60%;"></a></p> <p>数据帧中的VID字段标识了该数据帧所属的VLAN，数据帧只能在其所属VLAN内进行传输。<strong>VID字段代表VLAN ID，VLAN ID取值范围是0～4095</strong>。由于0和4095为协议保留取值，所以VLAN ID的有效取值范围是1～4094。</p> <p><strong>交换机内部处理的数据帧都带有VLAN标签</strong>。而交换机连接的部分设备（如用户主机、服务器）只会收发不带VLAN tag的传统以太网数据帧。因此，要与这些设备交互，就需要交换机的接口能够识别传统以太网数据帧，并在收发时给帧添加、剥除VLAN标签。添加什么VLAN标签，由接口上的缺省VLAN（Port Default VLAN ID，PVID）决定。</p> <ul> <li>终端设备不会生成带 VLAN 标签的数据帧，它们发出的数据帧叫做无标记帧（ Untagged ）。它们连接的交换机会给无标记帧打上 VLAN 标签。交换机通过每个端口的 PVID ，判断从这个接口收到的无标记帧属于哪个 VLAN ，并在转发时，插入相应的 VLAN 标签，从而将无标记帧变为标记帧（ Tagged ）。</li> </ul> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/365211791>37张图详解MAC地址、以太网、二层转发、VLAN</a></li> </ol> </blockquote> <hr> <p><strong>ARP协议</strong></p> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/370507243>ARP协议</a></li> </ol> </blockquote> <p><a class=glightbox href=../image/arp_frame.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img alt=ARP帧 src=../image/arp_frame.png></a></p> <ul> <li>Hardware type ：硬件类型，标识链路层协议</li> <li>Protocol type： 协议类型，标识网络层协议</li> <li>Hardware size ：硬件地址大小，标识MAC地址长度，这里是6个字节（48bit）</li> <li>Protocol size： 协议地址大小，标识IP地址长度，这里是4个字节（32bit）</li> <li>Opcode： 操作代码，标识ARP数据包类型，1表示请求，2表示回应</li> <li>Sender MAC address ：发送者MAC</li> <li>Sender IP address ：发送者IP</li> <li>Target MAC address ：目标MAC，此处全0表示在请求</li> <li>Target IP address： 目标IP</li> </ul> <p>ARP表项又分为动态ARP表项和静态ARP表项。</p> <ul> <li> <p>动态ARP表项</p> <ul> <li>动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。</li> </ul> </li> <li> <p>静态ARP表项</p> <ul> <li> <p>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖。直到重新启动计算机为止。</p> </li> <li> <p>配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时只使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，从而保护了本设备和指定设备间的正常通信。</p> </li> <li> <p>静态ARP表项分为短静态ARP表项和长静态ARP表项。</p> <ul> <li><strong>在配置长静态ARP表项时，除了配置IP地址和MAC地址项外，还必须配置该ARP表项所在VLAN和出接口。长静态ARP表项可以直接用于报文转发。</strong></li> <li>在配置短静态ARP表项时，只需要配置IP地址和MAC地址项。如果出接口是三层以太网接口，短静态ARP表项可以直接用于报文转发；如果出接口是VLAN虚接口，短静态ARP表项不能直接用于报文转发，当要发送IP数据包时，先发送ARP请求报文，如果收到的响应报文中的源IP地址和源MAC地址与所配置的IP地址和MAC地址相同，则将接收ARP响应报文的接口加入该静态ARP表项中，之后就可以用于IP数据包的转发。</li> </ul> </li> </ul> </li> </ul> <h4 id=513>5.1.3. 网络层<a class=headerlink href=#513 title="Permanent link">&para;</a></h4> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/374436165>路由表(RIB/FIB)、MAC表、ARP表介绍</a></li> <li><a href=https://www.zhihu.com/question/23328152/answer/137899901>路由表与转发表的区别</a></li> <li><a href=https://zhuanlan.zhihu.com/p/405894469>路由前缀、协议类型、优先级等</a></li> <li><a href=https://www.cnblogs.com/kika/p/10851602.html>Linux 内核的路由表</a></li> <li><a href=https://zhuanlan.zhihu.com/p/515239767>数据帧转发过程中IP地址及MAC地址的变化</a></li> </ol> </blockquote> <h4 id=514>5.1.4. 传输层<a class=headerlink href=#514 title="Permanent link">&para;</a></h4> <p>当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。</p> <p>简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。</p> <h4 id=515>5.1.5. 会话层<a class=headerlink href=#515 title="Permanent link">&para;</a></h4> <p>虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，自动寻址的功能。于是会话层出现了：它的作用就是建立和管理应用程序之间的通信。</p> <h4 id=516>5.1.6. 表示层<a class=headerlink href=#516 title="Permanent link">&para;</a></h4> <p>表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。</p> <h4 id=517>5.1.7. 应用层<a class=headerlink href=#517 title="Permanent link">&para;</a></h4> <blockquote> <ol> <li><a href=https://zhuanlan.zhihu.com/p/656097299>裸机移植lwIP</a></li> <li><a href=https://blog.csdn.net/yangzhao0001/article/details/48625927>LWIP使用经验</a></li> <li><a href=https://blog.csdn.net/weixin_43166744/article/details/126994853>Lwip数据传递流程及主要函数理解</a></li> </ol> </blockquote> <p><a class=glightbox href=../image/lwip_work_flow.png data-type=image data-width=100% data-height=auto data-desc-position=bottom><img src=../image/lwip_work_flow.png alt="Lwip 工作流程" style="width: 60%; height: 60%;"></a></p> <h2 id=6>6. 标准库<a class=headerlink href=#6 title="Permanent link">&para;</a></h2> <h3 id=61-newlib>6.1. newlib<a class=headerlink href=#61-newlib title="Permanent link">&para;</a></h3> <p>newlib是一个面向嵌入式系统的c运行库，可以裸机运行。</p> <p><strong>移植</strong></p> <p>Newlib的所有库函数都建立在20个桩函数的基础上，这20个桩函数完成一些newlib无法实现的功能：</p> <ol> <li>I/O和文件系统访问(open、close、read、write、lseek、stat、fstat、fcntl、link、unlink、rename)；</li> <li>扩大内存堆的需求(sbrk)；</li> <li>获得当前系统的日期和时间(gettimeofday、times)；</li> <li>各种类型的任务管理函数(execve、fork、getpid、kill、wait、_exit)；</li> </ol> <p>这20个桩函数在语义、语法上与POSIX标准下对应的20个同名系统调用是完全兼容的。<strong>成功移植newlib的关键是在目标系统环境下，找到能够与这些桩函数衔接的功能函数并实现这些桩函数。</strong></p> <p>Newlib为每个桩函数提供了可重入的和不可重入的两种版本。两种版本的区别在于，</p> <ul> <li> <p>不可重入版桩函数的名字是xxx，则对应的可重入版桩函数的名字是_xxx_r，如close和_close_r，open和_open_r，等等。</p> </li> <li> <p>此外，可重入的桩函数在参数表中含有一个_reent结构指针，这个指针使得系统的实现者能在库和目标操作环境之间传送上下文相关的信息，尤其是发生错误时，能够便捷的传送errno的值到适当的任务中。</p> </li> </ul> <p><strong>所谓最小实现是指假定将要移植的目标系统中没有文件系统，也没有符合POSIX标准的任务管理机制和应用编程接口(Application Programming Interface， API)，仅仅实现newlib的一个最小移植。</strong></p> <ol> <li> <p>在newlib的移植过程中全功能实现的桩函数只有open、close、read、write和sbrk五个，其他桩函数仅仅实现一个返回错误的空函数。</p> </li> <li> <p>任务管理的execve、fork、getpid、kill、wait和_exit六个桩函数，仅仅实现一个返回-1的空函数，返回之前将errno设置为ENOTSUP，表示系统不支持该函数。</p> </li> <li> <p>与文件相关的link和unlink桩函数也仅仅实现一个返回-1的空函数，将errno设置为EMLINK表示连接过多；lseek函数则不需要返回任何错误，直接返回0，表示操作成功。</p> </li> <li> <p>fstat和stat桩函数在newlib中主要用于判断流的类型(常规文件、字符设备、目录)，将其实现为不论输入参数如何，都返回字符设备类型的空函数。</p> </li> <li> <p>times桩函数返回当前进程中的各种时间信息，如果目标系统中的任务不能提供类似的时间信息，仅仅实现一个返回-1的空函数，将errno设置为ENOTSUP。</p> </li> <li> <p>由于newlib认为在目标系统中fcntl、rename和gettimeofday三个桩函数缺省是不提供的，所以也不提供这三个桩函数的实现。</p> </li> </ol> <p><strong>程序特点</strong></p> <p>C运行库的可重入性问题主要是<code>库中的全局变量</code>在<code>多任务环境</code>下的<code>可重入性问题</code>，Newlib解决这个问题的方法是：</p> <ol> <li> <p>定义一个struct _reent类型的结构，将运行库所有会引起可重入性问题的全局变量都放到该结构中。</p> </li> <li> <p>而这些全局变量则被重新定义为若干个宏，以errno为例，名为<code>errno</code>的宏引用指向struct _reent结构类型的一个全局指针，这个指针叫做<code>_impure_ptr</code>。</p> </li> <li> <p>对于用户，这一切都被errno宏隐藏了，需要检查错误时，用户只需要像其他ANSI C环境下所做的一样，检查<code>errno变量</code>就可以了。</p> <ul> <li>实际上，用户对errno宏的访问是返回<code>_impure_ptr-＞errno</code>的值，而不是一个全局变量的值。</li> </ul> </li> <li> <p>Newlib定义了_reent结构类型的一个静态实例，并在系统初始化时用全局指针<code>_impure_ptr</code>指向它。</p> <ul> <li>如果系统中只有一个任务，那么系统将正常运行，不需要做额外的工作；<strong>如果希望newlib运行在多任务环境下，必须完成下面的两个步骤</strong>：<ul> <li>每个任务提供一个_reent结构的实例并初始化；</li> <li>任务上下文切换的时刻重新设置_impure_ptr指针，使它指向即将投入运行任务的_reent结构实例。</li> </ul> </li> </ul> </li> </ol> <p>这样就可以保障大多数库函数(尤其是stdio库函数)的可重入性。如果需要可重入的malloc，还必须设法实现__malloc_lock()和__malloc_unlock()函数，它们在内存分配过程中保障堆(heap)在多任务环境下的安全。</p> <p><strong>I/O实现</strong></p> <p>Newlib在使用open、close、read和write桩函数时严格遵守POSIX标准，为了使实现的桩函数完全符合POSIX，<strong>就必须在内部机制上实现设备名表、文件描述符表和驱动地址表3个表的相关操作</strong>。</p> <ul> <li> <p>三个表的结构、作用及相关操作</p> </li> <li> <p>设备名表记录系统中所有设备的名字及其设备号。系统初始化时必须将所有的设备名及其设备号填入表中备查。</p> <ul> <li>对于设备名表应该实现以下两个操作：<ol> <li>设备名/设备号注册函数NameRegister；</li> <li>从设备名到设备号的转换函数NameLookup；</li> </ol> </li> </ul> </li> <li> <p>文件描述符表记录系统中当前打开的设备的设备号。每个表项代表一个处于打开状态的设备。每个表项的索引值就是需要返回给用户的文件描述符。</p> <ul> <li>对文件描述符表需要实现以下3个操作：<ol> <li>文件描述符分配函数FdAllocate；</li> <li>文件描述符释放函数FdFree；</li> <li>从文件描述符到设备号的转换函数Fd2DevCode；</li> </ol> </li> </ul> </li> <li> <p>驱动地址表记录系统中每个驱动程序的入口地址。每个表项代表一个驱动程序，对每个驱动程序都应该实现五个具有统一接口的操组函数：init、open、close、read、write。每个表项在表中的索引值就是该设备的设备号。需要注意是每个驱动程序都必须提供init操作。</p> <ul> <li>对驱动地址表需要实现以下操作：<ol> <li>初始化驱动表中的所有驱动函数InitAllDrivers；</li> <li>该操作对表中的每一个驱动程序调用init操作，完成表中所有驱动程序的初始化操作。</li> <li> <p>在系统初始化的时间，应该调用InitAllDrivers()操作，完成系统中所有驱动程序的初始化操作。在每个驱动程序的init操作中，应该调用NameRegister()操作，完成驱动程序对应的设备注册，以COM1驱动程序的com1_init()操作为例，它的实现如下：</p> <div class=highlight><pre><span></span><code><a id=__codelineno-23-1 name=__codelineno-23-1 href=#__codelineno-23-1></a><span class=kt>void</span><span class=w> </span><span class=nf>com1_init</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>devCode</span><span class=p>)</span>
<a id=__codelineno-23-2 name=__codelineno-23-2 href=#__codelineno-23-2></a><span class=p>{</span>
<a id=__codelineno-23-3 name=__codelineno-23-3 href=#__codelineno-23-3></a><span class=w>    </span><span class=cm>/*首先注册设备名和设备号到设备名表中*/</span>
<a id=__codelineno-23-4 name=__codelineno-23-4 href=#__codelineno-23-4></a><span class=w>    </span><span class=n>NameRegister</span><span class=p>(</span><span class=s>&quot;COM1&quot;</span><span class=err>，</span><span class=w> </span><span class=n>devCode</span><span class=p>);</span>
<a id=__codelineno-23-5 name=__codelineno-23-5 href=#__codelineno-23-5></a><span class=w>    </span><span class=cm>/*然后完成其他的设备初始化操作*/</span>
<a id=__codelineno-23-6 name=__codelineno-23-6 href=#__codelineno-23-6></a><span class=p>}</span>
</code></pre></div> </li> </ol> </li> </ul> </li> </ul> <p>只要所有的设备驱动程序都遵守这个约定，在系统初始化完成之后，系统中所有的驱动程序就得到了初始化，并且系统中所有的设备都注册到了设备名表中。后续的I/O桩函数的实现就非常容易了。</p> <p><strong>open 桩函数实现</strong></p> <ol> <li>用NameLookup()操作在设备名表中搜索匹配的设备名，并获得对应的设备号；</li> <li>用FdAllocate()操作从文件描述符表中分配一个空的表项，填入设备号，并获得对应的索引号即fd；</li> <li>通过设备号直接调用驱动地址表中对应驱动程序的open操作；</li> <li>返回fd。</li> </ol> <p><strong>read、write和close桩函数的实现</strong></p> <p>read和write桩函数的实现方法完全相同，流程如下：</p> <ol> <li>调用Fd2DevCode()操作获得与输入参数fd对应的设备号devCode；</li> <li>通过设备号直接调用驱动地址表中对应驱动的read或write操作；</li> <li>返回实际交换的数据量。</li> </ol> <p>close桩函数的实现与read、write几乎完全相同，唯一不同之处在于最后调用FdFree()操作，释放fd而不是返回实际交换的数据量，流程如下：</p> <ol> <li>调用Fd2DevCode()操作获得与输入参数fd对应的设备号devCode；</li> <li>通过设备号直接调用驱动地址表中对应驱动的close操作；</li> <li>调用FdFree()操作释放fd。</li> </ol> <p>至此，与设备I/O相关的四个桩函数open、close、read和write的实现就全部完成了。</p> <p>本文没有介绍驱动程序的实现方法，并不是驱动程序不重要，恰恰相反，驱动程序中必须完成可靠高效的设备操作，保证驱动程序的各项操作在语义上与上面4个桩函数完全一致，并且实质性的操作都在驱动程序中完成。因此，在驱动程序的实现上必须仔细斟酌。由于篇幅的原因，不再赘述。</p> <p><strong>malloc</strong></p> <p>大多数嵌入式操作系统都实现了自己的动态内存分配机制，并且提供了多任务环境下对内存分配机制的保护措施，如果移植newlib到这样的系统时，可以放弃newlib自带的malloc函数。尽管newlib自带的malloc非常高效，但是几乎所有的用户都习惯使用malloc来作为动态内存分配器。在这种情况下，最好对系统自带的动态内存分配API进行封装，使它不论在风格、外观上，还是在语义上都与malloc完全相同，这对于提高应用程序的可移植性大有好处。</p> <p>对于那些没有实现动态内存分配机制的嵌入式系统环境来说，newlib的malloc是一个非常好的选择，只需实现sbrk桩函数，malloc就可以非常好地工作起来。与之同名的POSIX系统调用的作用是从系统中获得一块内存，每当malloc需要更多的内存时，都会调用sbrk函数。</p> <p>在单任务环境下，只需实现sbrk桩函数，malloc就可以正常运行；但在多任务环境下，还需实现__malloc_lock()和__malloc_unlock()函数，newlib用这两个函数来保护内存堆免受冲击。用户可利用目标环境中的互斥信号量机制来实现这两个函数，在__malloc_lock()函数中申请互斥信号量，而在__malloc_unlock()函数中释放同一个互斥信号量。</p> <h2 id=7>7. 待完成<a class=headerlink href=#7 title="Permanent link">&para;</a></h2> <ul class=task-list> <li class=task-list-item> <p><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> ABI，Application Binary Interface是什么？主要是两方面</p> <ul> <li>calling convention，即调用一个函数的时候怎么传参，是<code>按顺序给放到栈上</code>（栈顶被一个寄存器指定），还是<code>用多个寄存器</code>。<ul> <li>它规定了堆栈寄存器、链接寄存器、哪些寄存器寄存器需要在函数头尾保存和恢复、哪些寄存器可以作为参数寄存器等，还有一些特殊用途的寄存器。大部分特殊寄存器都是会被高频使用的，配合指令集设计可以降低代码密度；需要保存和恢复的寄存器个数同样也会影响代码密度。</li> </ul> </li> <li>name mangle，即C++写的函数或者方法以及一切可以引用的东西，在可执行文件里面的符号是怎么样生成的，除非你指定extern "C"，否则C++不会原样导出符号</li> <li>它指导着编译器如何生成代码和二进制程序，同样也指导着用户如何写汇编代码。它主要包含函数调用约定（calling convention）、数据的对齐方式等内容。</li> </ul> </li> <li class=task-list-item> <p><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> <a href=https://www.zhihu.com/question/49580321>不依赖操作系统的C代码</a></p> </li> <li class=task-list-item> <p><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 锁的用途</p> <ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 进程调度<ul> <li>自旋锁和多核</li> <li>互斥锁和单核</li> <li>原子操作</li> </ul> </li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 锁实现原理</li> </ul> </li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 堆栈概念<ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 内核栈</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 进程/线程栈</li> </ul> </li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 内存相关问题<ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 内存泄漏如何解决<ul> <li>gdb、fstrace工具</li> <li>asan</li> </ul> </li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled><span class=task-list-indicator></span></label> 非法内存读写操作<ul> <li>踩栈</li> <li>非法指令</li> </ul> </li> </ul> </li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> 内核空间和进程空间<ul> <li><a href=https://zhuanlan.zhihu.com/p/366964820>mmap原理</a></li> </ul> </li> </ul> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> Back to top </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2024 - 2024 Pikaqiu </div> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "..", "features": ["navigation.top"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../assets/javascripts/bundle.1e8ae164.min.js></script> <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body> </html>